[{"title":"linux下搭建go环境","date":"2018-05-26T17:01:37.000Z","path":"2018/05/27/linux下搭建go环境/","text":"安装go工具 在 http://golang.org/dl/下载最新的linux版本，并把它提取到/usr/local目录，在此目录下进行解压缩 $ tar -xvf xxx.tar.gz 然后将/usr/local/go/bin添加到PATH环境变量中，执行 $ vim /etc/profile $ export PATH=$PATH:/usr/local/go/bin $ source /etc/profile 实际上go会默认假定它被安装到/usr/local/go目录下，但也可以将go安装到其他位置，此时必须设置GOROOT环境变量来指出它所安装的位置。 执行go version，看到go的安装版本即安装成功 第一个hello world 程序 GOPATH环境变量指定了你的工作空间位置 首先创建一个工作目录，并设置相应的GOPATH，工作目录可以放在任何地方，但不能和go的安装目录相同，在这我们使用$HOME/work $ mkdir $HOME/work $ vim /etc/profile $ export GOPATH=$HOME/work 注意：go的代码必须放在工作空间内，也就是我们这里的work目录下，其中包含了三个子目录 bin目录包含可执行命令 pkg目录包含包对象 src目录包含go的源文件，它们被组织成包（每个目录都对应一个包） 接下来将工作空间的bin子目录添加到PATH中： $ vim /etc/profile $ export PATH=$PATH:$GOPATH/bin $ source /etc/profile 包路径：标准库中的包有给定的短路径比如”fmt”，对于你自己的包，也必须选择一个基本路径，来保证它不会与将来添加到标准库或其他标准库中的包相冲突。 使用packs作为基本路径，在你的工作空间里创建一个目录，我们将源码放在其中： mkdir $GOPATH/src/packs 要编译运行简单的程序，首先要选择包路径，在这里我们使用packs/hello，并在你的工作空间内创建相应的包目录： $ mkdir $GOPATH/src/packs/hello 接着在该目录中创建名为hello.go的文件，其内容如下 package main import &quot;fmt&quot; func main() { fmt.Printf(&quot;Hello, world.\\n&quot;) } 现在可以使用go工具构建并安装此程序了 $ go install packs/hello 注意，你可以在系统的任何地方运行此命令。go工具会根据GOPATH指定的工作空间，在packs/hello包内查找源码。如果从包目录中运行go install，也可以省略包路径： $ cd $GOPATH/src/packs/hello $ go install 此命令会构建hello命令，产生一个可执行的二进制文件。并存放在工作空间的bin目录下，在这里就是$GOPATH/bin目录下因为已经将$GOPATH/bin添加到PATH中，只需要输入该二进制文件名执行即可 $ hello Hello, world.","tags":[{"name":"linux","slug":"linux","permalink":"http://blog.xmqbeast.com/tags/linux/"}]},{"title":"什么是MVVM","date":"2018-05-15T09:57:17.000Z","path":"2018/05/15/什么是MVVM/","text":"什么是MVVM？MVVM是Model-View-ViewModel的缩写。 要编写可维护的前端代码绝非易事。我们已经用MVC模式通过koa实现了后端数据、模板页面和控制器的分离，但是，对于前端来说，还不够。 这里有童鞋会问，不是讲Node后端开发吗？怎么又回到前端开发了？ 对于一个全栈开发工程师来说，懂前端才会开发出更好的后端程序（不懂前端的后端工程师会设计出非常难用的API），懂后端才会开发出更好的前端程序。程序设计的基本思想在前后端都是通用的，两者并无本质的区别。这和“不想当厨子的裁缝不是好司机”是一个道理。 当我们用Node.js有了一整套后端开发模型后，我们对前端开发也会有新的认识。由于前端开发混合了HTML、CSS和JavaScript，而且页面众多，所以，代码的组织和维护难度其实更加复杂，这就是MVVM出现的原因。 在了解MVVM之前，我们先回顾一下前端发展的历史。 在上个世纪的1989年，欧洲核子研究中心的物理学家Tim Berners-Lee发明了超文本标记语言（HyperText Markup Language），简称HTML，并在1993年成为互联网草案。从此，互联网开始迅速商业化，诞生了一大批商业网站。 最早的HTML页面是完全静态的网页，它们是预先编写好的存放在Web服务器上的html文件。浏览器请求某个URL时，Web服务器把对应的html文件扔给浏览器，就可以显示html文件的内容了。 如果要针对不同的用户显示不同的页面，显然不可能给成千上万的用户准备好成千上万的不同的html文件，所以，服务器就需要针对不同的用户，动态生成不同的html文件。一个最直接的想法就是利用C、C++这些编程语言，直接向浏览器输出拼接后的字符串。这种技术被称为CGI：Common Gateway Interface。 很显然，像新浪首页这样的复杂的HTML是不可能通过拼字符串得到的。于是，人们又发现，其实拼字符串的时候，大多数字符串都是HTML片段，是不变的，变化的只有少数和用户相关的数据，所以，又出现了新的创建动态HTML的方式：ASP、JSP和PHP——分别由微软、SUN和开源社区开发。 在ASP中，一个asp文件就是一个HTML，但是，需要替换的变量用特殊的&lt;%=var%&gt;标记出来了，再配合循环、条件判断，创建动态HTML就比CGI要容易得多。 但是，一旦浏览器显示了一个HTML页面，要更新页面内容，唯一的方法就是重新向服务器获取一份新的HTML内容。如果浏览器想要自己修改HTML页面的内容，就需要等到1995年年底，JavaScript被引入到浏览器。 有了JavaScript后，浏览器就可以运行JavaScript，然后，对页面进行一些修改。JavaScript还可以通过修改HTML的DOM结构和CSS来实现一些动画效果，而这些功能没法通过服务器完成，必须在浏览器实现。 用JavaScript在浏览器中操作HTML，经历了若干发展阶段： 第一阶段，直接用JavaScript操作DOM节点，使用浏览器提供的原生API： var dom = document.getElementById(&apos;name&apos;); dom.innerHTML = &apos;Homer&apos;; dom.style.color = &apos;red&apos;; 第二阶段，由于原生API不好用，还要考虑浏览器兼容性，jQuery横空出世，以简洁的API迅速俘获了前端开发者的芳心： $(&apos;#name&apos;).text(&apos;Homer&apos;).css(&apos;color&apos;, &apos;red&apos;); 第三阶段，MVC模式，需要服务器端配合，JavaScript可以在前端修改服务器渲染后的数据。 现在，随着前端页面越来越复杂，用户对于交互性要求也越来越高，想要写出Gmail这样的页面，仅仅用jQuery是远远不够的。MVVM模型应运而生。 MVVM最早由微软提出来，它借鉴了桌面应用程序的MVC思想，在前端页面中，把Model用纯JavaScript对象表示，View负责显示，两者做到了最大限度的分离。 把Model和View关联起来的就是ViewModel。ViewModel负责把Model的数据同步到View显示出来，还负责把View的修改同步回Model。 ViewModel如何编写？需要用JavaScript编写一个通用的ViewModel，这样，就可以复用整个MVVM模型了。 一个MVVM框架和jQuery操作DOM相比有什么区别？ 我们先看用jQuery实现的修改两个DOM节点的例子： &lt;!-- HTML --&gt; &lt;p&gt;Hello, &lt;span id=&quot;name&quot;&gt;Bart&lt;/span&gt;!&lt;/p&gt; &lt;p&gt;You are &lt;span id=&quot;age&quot;&gt;12&lt;/span&gt;.&lt;/p&gt; Hello, Homer! You are 52. 用jQuery修改name和age节点的内容： &apos;use strict&apos;; var name = &apos;Homer&apos;; var age = 52; $(&apos;#name&apos;).text(name); $(&apos;#age&apos;).text(age); 如果我们使用MVVM框架来实现同样的功能，我们首先并不关心DOM的结构，而是关心数据如何存储。最简单的数据存储方式是使用JavaScript对象： var person = { name: ‘Bart’, age: 12}; 我们把变量person看作Model，把HTML某些DOM节点看作View，并假定它们之间被关联起来了。 要把显示的name从Bart改为Homer，把显示的age从12改为51，我们并不操作DOM，而是直接修改JavaScript对象： Hello, Homer! You are 51 &apos;use strict&apos;; person.name = &apos;Homer&apos;; person.age = 51; 执行上面的代码，我们惊讶地发现，改变JavaScript对象的状态，会导致DOM结构作出对应的变化！这让我们的关注点从如何操作DOM变成了如何更新JavaScript对象的状态，而操作JavaScript对象比DOM简单多了！ 这就是MVVM的设计思想：关注Model的变化，让MVVM框架去自动更新DOM的状态，从而把开发者从操作DOM的繁琐步骤中解脱出来！","tags":[{"name":"js","slug":"js","permalink":"http://blog.xmqbeast.com/tags/js/"}]},{"title":"netty5简介","date":"2018-05-15T03:35:32.000Z","path":"2018/05/15/netty5简介/","text":"Netty是一个非web的java应用，Java序列化的作用有以下两方面： 1） 把对象的字节序列永久地保存到硬盘上（通常存放在一个文件中）； 2） 在网络上传送对象的字节序列。 NIO和IO最大的区别是数据打包和传输方式。IO是以流的方式处理数据，而NIO是以块的方式处理数据。 面向流的IO一次一个字节的处理数据，一个输入流产生一个字节，一个输出流就消费一个字节。为流式数据创建过滤器就变得非常容易，链接几个过滤器，以便对数据进行处理非常方便而简单，但是面向流的IO通常处理的很慢。 面向块的IO系统以块的形式处理数据。每一个操作都在一步中产生或消费一个数据块。按块要比按流快的多，但面向块的IO缺少了面向流IO所具有的有雅兴和简单性。 Channel是一个对象，可以通过它读取和写入数据。可以把它看做IO中的流。但是它和流相比还有一些不同：Channel是双向的，既可以读又可以写，而流是单向的，Channel可以进行异步的读写，对Channel的读写必须通过buffer对象 在Java NIO中Channel主要有如下几种类型： FileChannel：从文件读取数据的 DatagramChannel：读写UDP网络协议数据 SocketChannel：读写TCP网络协议数据 ServerSocketChannel：可以监听TCP连接 Netty5与其他版本的区别： ChannelInboundHandler和ChannelOutboundHandler整合为ChannelHandler。ChannelHandler现在包含输入和输出的处理方法。 ChannelInboundHandlerAdapter，ChannelOutboundHandlerAdapter和ChannelDuplexHandlerAdapter已被废弃，由 ChannelHandlerAdapter代替。 由于现在无法区分处理器(handler) 是输入还是输出的处理器，CombinedChannelDuplexHandler现在由 ChannelHandlerAppender代替。 更多相关变化，可参考https://github.com/netty/netty/pull/1999 channelRead0() → messageReceived() 我知道。这是一个愚蠢的错误。如果你使用了SimpleChannelInboundHandler，你需要把channelRead0()重命名为messageReceived()。 ChannelInitializer，当一个链接建立时，我们需要知道怎么来接收或者发送数据，当然，我们有各种各样的Handler实现来处理它，那么ChannelInitializer便是用来配置这些Handler，它会提供一个ChannelPipeline，并把Handler加入到ChannelPipeline。 ChannelPipeline，ChannelPipeline实际上应该叫做ChannelHandlerPipeline，可以把ChannelPipeline看成是一个ChandlerHandler的链表，当需要对Channel进行某种处理的时候，Pipeline负责依次调用每一个Handler进行处理。每个Channel都有一个属于自己的Pipeline，调用Channel#pipeline()方法可以获得Channel的Pipeline，调用Pipeline#channel()方法可以获得Pipeline的Channel。一个Netty应用基于ChannelPipeline机制，这种机制需要依赖于EventLoop和EventLoopGroup，因为它们三个都和事件或者事件处理相关。 EventLoops的目的是为Channel处理IO操作，一个EventLoop可以为多个Channel服务。 EventLoopGroup会包含多个EventLoop。 Channel代表了一个Socket链接，或者其它和IO操作相关的组件，它和EventLoop一起用来参与IO处理。 Future，在Netty中所有的IO操作都是异步的，因此，你不能立刻得知消息是否被正确处理，但是我们可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过Future和ChannelFutures,他们可以注册一个监听，当操作执行成功或失败时监听会自动触发。总之，所有的操作都会返回一个ChannelFuture。 Netty是一个非阻塞的、事件驱动的、网络编程框架。当然，我们很容易理解Netty会用线程来处理IO事件，对于熟悉多线程编程的人来说，你或许会想到如何同步你的代码，但是Netty不需要我们考虑这些，具体是这样： 一个Channel会对应一个EventLoop，而一个EventLoop会对应着一个线程，也就是说，仅有一个线程在负责一个Channel的IO操作。 当一个ChannelHandler被加入到ChannelPipeline中时，它便会获得一个ChannelHandlerContext的引用，而ChannelHandlerContext可以用来读写Netty中的数据流。因此，现在可以有两种方式来发送数据，一种是把数据直接写入Channel，一种是把数据写入ChannelHandlerContext，它们的区别是写入Channel的话，数据流会从Channel的头开始传递，而如果写入ChannelHandlerContext的话，数据流会流入管道中的下一个Handler。 我们最关心的部分，如何处理我们的业务逻辑？ 通常继承基类ChannelHandlerAdapter Netty中会有很多Handler，具体是哪种Handler还要看它们继承的是InboundAdapter还是OutboundAdapter。当然，Netty中还提供了一些列的Adapter来帮助我们简化开发，我们知道在Channelpipeline中每一个Handler都负责把Event传递给下一个Handler，如果有了这些辅助Adapter，这些额外的工作都可自动完成，我们只需覆盖实现我们真正关心的部分即可。此外，还有一些Adapter会提供一些额外的功能，比如编码和解码。那么下面我们就来看一下其中的三种常用的ChannelHandler： Encoders和Decoders 因为我们在网络传输时只能传输字节流，因此，才发送数据之前，我们必须把我们的message型转换为bytes，与之对应，我们在接收数据后，必须把接收到的bytes再转换成message。我们把bytes to message这个过程称作Decode(解码成我们可以理解的)，把message to bytes这个过程成为Encode。 Netty中提供了很多现成的编码/解码器，我们一般从他们的名字中便可知道他们的用途，如ByteToMessageDecoder、MessageToByteEncoder，如专门用来处理Google Protobuf协议的ProtobufEncoder、 ProtobufDecoder。","tags":[{"name":"netty","slug":"netty","permalink":"http://blog.xmqbeast.com/tags/netty/"}]},{"title":"java中BIO、NIO、AIO的区别","date":"2018-05-15T03:31:13.000Z","path":"2018/05/15/java中BIO、NIO、AIO的区别/","text":"java中的IO主要源自于网络和本地文件 IO的方式通常分为几种，同步阻塞的BIO、同步非阻塞的NIO、异步非阻塞的AIO 在JDK1.4出来之前，我们建立网络连接的时候采用BIO模式，需要先在服务端启动一个ServerSocket，然后在客户端启动Socket来对服务端进行通信，默认情况下服务端需要对每个请求建立一堆线程等待请求，而客户端发送请求后，先咨询服务端是否有线程相应，如果没有则会一直等待或者遭到拒绝请求，如果有的话，客户端会线程会等待请求结束后才继续执行。 BIO与NIO一个比较重要的不同，是我们使用BIO的时候往往会引入多线程，每个连接一个单独的线程；而NIO则是使用单线程或者只使用少量的多线程，每个连接共用一个线程。 NIO的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。 在NIO的处理方式中，当一个请求来的话，开启线程进行处理，可能会等待后端应用的资源(JDBC连接等)，其实这个线程就被阻塞了，当并发上来的话，还是会有BIO一样的问题。 HTTP/1.1出现后，有了Http长连接，这样除了超时和指明特定关闭的http header外，这个链接是一直打开的状态的，这样在NIO处理中可以进一步的进化，在后端资源中可以实现资源池或者队列，当请求来的话，开启的线程把请求和请求数据传送给后端资源池或者队列里面就返回，并且在全局的地方保持住这个现场(哪个连接的哪个请求等)，这样前面的线程还是可以去接受其他的请求，而后端的应用的处理只需要执行队列里面的就可以了，这样请求处理和后端应用是异步的.当后端处理完，到全局地方得到现场，产生响应，这个就实现了异步处理。 BIO是一个连接一个线程。 NIO是一个请求一个线程。 AIO是一个有效请求一个线程。 先来个例子理解一下概念，以银行取款为例：同步 ： 自己亲自出马持银行卡到银行取钱（使用同步IO时，Java自己处理IO读写）。异步 ： 委托一小弟拿银行卡到银行取钱，然后给你（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS(银行卡和密码)，OS需要支持异步IO操作API）。阻塞 ： ATM排队取款，你只能等待（使用阻塞IO时，Java调用会一直阻塞到读写完成才返回）。非阻塞 ： 柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞IO时，如果不能读写Java调用会马上返回，当IO事件分发器会通知可读写时再继续进行读写，不断循环直到读写完成） Java对BIO、NIO、AIO的支持： Java BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理， BIO、NIO、AIO适用场景分析: BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。另外，I/O属于底层操作，需要操作系统支持，并发也需要操作系统的支持，所以性能方面不同操作系统差异会比较明显。 在高性能的I/O设计中，有两个比较著名的模式Reactor和Proactor模式，其中Reactor模式用于同步I/O，而Proactor运用于异步I/O操作。 在比较这两个模式之前，我们首先的搞明白几个概念，什么是阻塞和非阻塞，什么是同步和异步,同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪，而异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知。而阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。 一般来说I/O模型可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞IO 同步阻塞IO： 在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。JAVA传统的IO模型属于此种方式！ 同步非阻塞IO: 在此种方式下，用户进程发起一个IO操作以后边可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。 异步阻塞IO： 此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄，从而提高系统的并发性！ 异步非阻塞IO: 在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。目前Java中还没有支持此种IO模型。 搞清楚了以上概念以后，我们再回过头来看看，Reactor模式和Proactor模式。 首先来看看Reactor模式，Reactor模式应用于同步I/O的场景。我们分别以读操作和写操作为例来看看Reactor中的具体步骤： 读取操作： 应用程序注册读就需事件和相关联的事件处理器 事件分离器等待事件的发生 当发生读就需事件的时候，事件分离器调用第一步注册的事件处理器 事件处理器首先执行实际的读取操作，然后根据读取到的内容进行进一步的处理 写入操作类似于读取操作，只不过第一步注册的是写就绪事件。 下面我们来看看Proactor模式中读取操作和写入操作的过程： 读取操作： 应用程序初始化一个异步读取操作，然后注册相应的事件处理器，此时事件处理器不关注读取就绪事件，而是关注读取完成事件，这是区别于Reactor的关键。 事件分离器等待读取操作完成事件 在事件分离器等待读取操作完成的时候，操作系统调用内核线程完成读取操作，并将读取的内容放入用户传递过来的缓存区中。这也是区别于Reactor的一点，Proactor中，应用程序需要传递缓存区。 事件分离器捕获到读取完成事件后，激活应用程序注册的事件处理器，事件处理器直接从缓存区读取数据，而不需要进行实际的读取操作。 Proactor中写入操作和读取操作，只不过感兴趣的事件是写入完成事件。 从上面可以看出，Reactor和Proactor模式的主要区别就是真正的读取和写入操作是有谁来完成的，Reactor中需要应用程序自己读取或者写入数据，而Proactor模式中，应用程序不需要进行实际的读写过程，它只需要从缓存区读取或者写入即可，操作系统会读取缓存区或者写入缓存区到真正的IO设备. 综上所述，同步和异步是相对于应用和内核的交互方式而言的，同步 需要主动去询问，而异步的时候内核在IO事件发生的时候通知应用程序，而阻塞和非阻塞仅仅是系统在调用系统调用的时候函数的实现方式而已。","tags":[{"name":"nio","slug":"nio","permalink":"http://blog.xmqbeast.com/tags/nio/"}]},{"title":"eclipse debug启动老是跳转到断点，提示SilentExitException","date":"2018-05-15T03:21:28.000Z","path":"2018/05/15/eclipse-debug启动老是跳转到断点，提示SilentExitException/","text":"最近在做一个spring boot的项目，在main方法debug启动的时候，老是自动跳转到断点，如下图所示 出现这种状况是因为Eclipse默认开启挂起未捕获的异常(Suspend execution on uncaught exceptions)，只要关闭此项就可以了。 解决方法：在eclipse中选择Window-&gt;Preference-&gt;Java-&gt;Debug，将“Suspend execution on uncaught exceptions”的勾去掉即可。","tags":[{"name":"eclipse","slug":"eclipse","permalink":"http://blog.xmqbeast.com/tags/eclipse/"}]},{"title":"java中socket的用法","date":"2018-05-14T17:58:04.000Z","path":"2018/05/15/java中socket的用法/","text":"Java中的Socket的用法 Java中的Socket分为普通的Socket和NioSocket。 普通Socket的用法 Java中的网络通信时通过Socket实现的，Socket分为ServerSocket和Socket两大类，ServerSocket用于服务器端，可以通过accept方法监听请求，监听请求后返回Socket，Socket用于完成具体数据传输，客户端也可以使用Socket发起请求并传输数据。ServerSocket的使用可以分为三步： 创建ServerSocket。ServerSocket的构造方法有5个，其中最方便的是ServerSocket(int port)，只需要一个port就可以了。调用创建出来的ServerSocket的accept方法进行监听。accept方法是阻塞方法，也就是说调用accept方法后程序会停下来等待连接请求，在接受请求之前程序将不会继续执行，当接收到请求后accept方法返回一个Socket。 使用accept方法返回的Socket与客户端进行通信 如下代码，我们在服务器端创建ServerSocket，并调用accept方法监听Client的请求，收到请求后返回一个Socket。 public class Server { public static void main(String[] args) { // TODO Auto-generated method stub try { //创建一个ServerSocket监听8080端口 ServerSocket server = new ServerSocket(8080); //等待请求 Socket socket = server.accept(); //接受请求后使用Socket进行通信，创建BufferedReader用于读取数据 BufferedReader is = new BufferedReader(new InputStreamReader(socket.getInputStream())); String line = is.readLine(); System.out.println(&quot;received frome client:&quot; + line); //创建PrintWriter，用于发送数据 PrintWriter pw = new PrintWriter(socket.getOutputStream()); pw.println(&quot;this data is from server&quot;); pw.flush(); //关闭资源 pw.close(); is.close(); socket.close(); server.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } 然后我们再看看客户端的Socket代码，Socket的使用也是一样，首先创建一个Socket，Socket的构造方法非常多，这里用的是Socket(String host, int port)，把目标主机的地址和端口号传入即可（本实验代码中服务器和Client代码没有在同一台机器上，服务器的IP地址：192.168.6.42，所以如果读者在实验过程中ServerSocket和Client在同一主机下，那么Client中的IP地址需要更改为：127.0.0.1，Socket创建的过程就会跟服务器端建立连接，创建完Socket后，再创建Writer和Reader来传输数据，数据传输完成后释放资源关闭连接。 public class Client { public static void main(String[] args) { // TODO Auto-generated method stub String msg = &quot;Client data&quot;; try { //创建一个Socket，跟服务器的8080端口链接 Socket socket = new Socket(&quot;192.168.6.42&quot;,8080); //使用PrintWriter和BufferedReader进行读写数据 PrintWriter pw = new PrintWriter(socket.getOutputStream()); BufferedReader is = new BufferedReader(new InputStreamReader(socket.getInputStream())); //发送数据 pw.println(msg); pw.flush(); //接收数据 String line = is.readLine(); System.out.println(&quot;received from server&quot; + line); //关闭资源 pw.close(); is.close(); socket.close(); } catch (UnknownHostException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } 最后先启动Server然后启动Client就可以完成一次Client和Server的通信。 NioSocket的用法 从JDK1.4开始，Java增加了新的IO模式-nio（new IO），nio在底层采用了新的处理方式，极大提高了IO的效率。我们使用的Socket也是IO的一种，nio提供了相应的工具：ServerSocketChannel和SocketChannel，他们分别对应原来的ServerSocket和Socket。 在了解NioSocket之前我们先了解Buffer、Channel、Selector。为了方便理解，我们来看个例子，要过圣诞节了，需要给同学们发贺卡和苹果，班长这时候又是最辛苦的，每次拿一个苹果和一张贺卡发给一个同学，发送完成后回来再取一张贺卡和一个苹果发给另一个同学，直到全班同学都拿到贺卡和苹果为止，这就是普通Socket处理方式，来一个请求，ServerSocket就进行处理，处理完成后继续接受请求，这种方式效率很低啊！还是圣诞节的例子，班长发现班委不止他一个，就通知了生活委员（女）和组织委员（男）来帮助他发贺卡和苹果，女生的贺卡是粉色的，男生的贺卡是蓝色的，生活委员负责从全班的贺卡中挑选女生的贺卡，而组织委员则负责男生的贺卡，然后生活委员和组织委员分别以宿舍为单位通知宿舍长来领取宿舍同学的贺卡和苹果，班长将圣诞节发苹果和贺卡的工作布置给两个班委后，就可以继续干其他工作了。这就是NioSocket，Buffer就是所有传递的货物，也就是例子中的苹果和贺卡，而Channel就是传递货物的通道，也就是例子中的宿舍长，负责将礼物搬回自己宿舍，而生活委员和组织委员充当了Selector的职责，负责礼物的分拣。 ServerSocketChannel可以使用自己的静态工厂方法open创建，每个ServerSocketChannel对应一个ServerSocket（通过调用其socket()获取），如果直接使用获取的ServerSocket来监听请求，那么还是普通ServerSocket，而通过将获取的ServerSocket绑定端口号来实现NioSocket。ServerSocketChannel可以通过configureBlocking方法来设置是否采用阻塞模式，如果设置为非阻塞模式，就可以调用register方法注册Selector来使用了。 Selector可以通过其静态工厂方法open创建，创建后通过Channel的register方法注册到ServerSocketChannel或者SocketChannel上，注册完成后Selector就可以通过select方法来等待请求，select方法有一个long类型参数，代表最长等待时间，如果在这段时间内收到相应操作的请求则返回可以处理的请求的数量，否则在超时后返回0，如果传入的参数为0或者无参数的重载方法，select方法会采用阻塞模式知道有相应操作请求的出现。当接收到请求后Selector调用selectdKeys方法返回SelectionKey集合。 SelectionKey保存了处理当前请求的Channel和Selector，并且提供了不同的操作类型。Channel在注册Selector时可以通过register的第二个参数选择特定的操作（请求操作、连接操作、读操作、写操作），只有在register中注册了相应的操作Selector才会关心相应类型操作的请求。 我们来看看服务器端NioSocket的处理过程： 创建ServerSocketChannel并设置相应的端口号、是否为阻塞模式创建Selector并注册到ServerSocketChannel上调用Selector的selector方法等待请求Selector接收到请求后使用selectdKeys返回SelectionKey集合使用SelectionKey获取到channel、selector和操作类型并进行具体操作。 public class NIOServer { public static void main(String[] args) { // TODO Auto-generated method stub try { //创建ServerSocketChannel，监听8080端口 ServerSocketChannel ssc = ServerSocketChannel.open(); ssc.socket().bind(new InetSocketAddress(8080)); //设置为非阻塞模式 ssc.configureBlocking(false); //为ssc注册选择器 Selector selector = Selector.open(); ssc.register(selector, SelectionKey.OP_ACCEPT); //创建处理器 Handler handler = new Handler(1024); while(true){ //等待请求，每次等待阻塞3s，超过3s后线程继续向下运行，如果传入0或者不传入参数则一直阻塞 if(selector.select(3000) == 0){ System.out.println(&quot;等待请求超时----&quot;); continue; } System.out.println(&quot;处理请求----&quot;); //获取处理的SelectionKey Iterator&lt;SelectionKey&gt; keyIter = selector.selectedKeys().iterator(); while(keyIter.hasNext()){ SelectionKey key = keyIter.next(); try{ //接收到连接请求时 if(key.isAcceptable()){ handler.handleAccept(key); } //读数据 if(key.isReadable()){ handler.handleRead(key); } }catch(IOException ex){ keyIter.remove(); continue; } //处理完后，从待处理的SelectionKey迭代器中移除当前所使用的key keyIter.remove(); } } } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } private static class Handler{ private int bufferSize = 1024; private String localCharset = &quot;UTF-8&quot;; public Handler(int bufferSize){ this.bufferSize = bufferSize; } public void handleAccept(SelectionKey key) throws IOException{ SocketChannel sc = ((ServerSocketChannel) key.channel()).accept(); sc.configureBlocking(false); sc.register(key.selector(), SelectionKey.OP_READ, ByteBuffer.allocate(bufferSize)); } public void handleRead(SelectionKey key) throws IOException{ //获取Channel SocketChannel sc = (SocketChannel) key.channel(); //获取buffer并重置 ByteBuffer buffer = (ByteBuffer)key.attachment(); buffer.clear(); //没有读到内容则关闭 if(sc.read(buffer) == -1) sc.close(); else{ //将buffer转换为读状态 buffer.flip(); //将buffer中接收到的值按localCharset格式编码后保存到receivedString String receivedString = Charset.forName(localCharset).newDecoder().decode(buffer).toString(); System.out.println(&quot;received from client:&quot; + receivedString); //返回数据给客户端 String sendString = &quot;this data is from Server&quot;; buffer = ByteBuffer.wrap(sendString.getBytes(localCharset)); sc.write(buffer); sc.close(); } } } } 客户端代码通普通Socket一样，Socket socket = new Socket(“127.0.0.1”,8080);表示与服务器端建立连接，从而执行服务器端的handleAccept()方法，给ServerSocketChannel注册selector以及添加SelectionKey.OP_READ参数，表示selector关心读方法。然后通过PrintWrite在客户端将内容发送给服务器端，服务器端执行handleRead方法对接收到的内容进行处理，并将结果返回给客户端，客户端通过BufferedReader接受数据","tags":[{"name":"socket","slug":"socket","permalink":"http://blog.xmqbeast.com/tags/socket/"}]},{"title":"redis list列表","date":"2018-05-14T02:50:25.000Z","path":"2018/05/14/redis-list列表/","text":"模式：安全的队列 Redis的列表经常被用作队列(queue)，用于在不同程序之间有序地交换消息(message)。一个客户端通过 LPUSH 命令将消息放入队列中，而另一个客户端通过 RPOP 或者 BRPOP 命令取出队列中等待时间最长的消息。 不幸的是，上面的队列方法是『不安全』的，因为在这个过程中，一个客户端可能在取出一个消息之后崩溃，而未处理完的消息也就因此丢失。 使用 RPOPLPUSH 命令(或者它的阻塞版本 BRPOPLPUSH )可以解决这个问题：因为它不仅返回一个消息，同时还将这个消息添加到另一个备份列表当中，如果一切正常的话，当一个客户端完成某个消息的处理之后，可以用 LREM 命令将这个消息从备份表删除。 最后，还可以添加一个客户端专门用于监视备份表，它自动地将超过一定处理时限的消息重新放入队列中去(负责处理该消息的客户端可能已经崩溃)，这样就不会丢失任何消息了。 模式：循环列表 通过使用相同的 key 作为 RPOPLPUSH 命令的两个参数，客户端可以用一个接一个地获取列表元素的方式，取得列表的所有元素，而不必像 LRANGE 命令那样一下子将所有列表元素都从服务器传送到客户端中(两种方式的总复杂度都是 O(N))。 以上的模式甚至在以下的两个情况下也能正常工作： 有多个客户端同时对同一个列表进行旋转(rotating)，它们获取不同的元素，直到所有元素都被读取完，之后又从头开始。有客户端在向列表尾部(右边)添加新元素。这个模式使得我们可以很容易实现这样一类系统：有 N 个客户端，需要连续不断地对一些元素进行处理，而且处理的过程必须尽可能地快。一个典型的例子就是服务器的监控程序：它们需要在尽可能短的时间内，并行地检查一组网站，确保它们的可访问性。 注意，使用这个模式的客户端是易于扩展(scala)且安全(reliable)的，因为就算接收到元素的客户端失败，元素还是保存在列表里面，不会丢失，等到下个迭代来临的时候，别的客户端又可以继续处理这些元素了。","tags":[{"name":"redis","slug":"redis","permalink":"http://blog.xmqbeast.com/tags/redis/"}]},{"title":"Redis Rpush命令","date":"2018-05-13T18:30:50.000Z","path":"2018/05/14/Redis-Rpush命令/","text":"Redis Rpush 命令 Redis Rpush 命令用于将一个或多个值插入到列表的尾部(最右边)。如果列表不存在，一个空列表会被创建并执行 RPUSH 操作。 当列表存在但不是列表类型时，返回一个错误。 注意：在 Redis 2.4 版本以前的 RPUSH 命令，都只接受单个 value 值。 语法redis Rpush 命令基本语法如下： redis 127.0.0.1:6379&gt; RPUSH KEY_NAME VALUE1..VALUEN 返回值执行 RPUSH 操作后，列表的长度。 实例 redis 127.0.0.1:6379&gt; RPUSH mylist &quot;hello&quot; (integer) 1 redis 127.0.0.1:6379&gt; RPUSH mylist &quot;foo&quot; (integer) 2 redis 127.0.0.1:6379&gt; RPUSH mylist &quot;bar&quot; (integer) 3 redis 127.0.0.1:6379&gt; LRANGE mylist 0 -1 1) &quot;hello&quot; 2) &quot;foo&quot; 3) &quot;bar&quot;","tags":[{"name":"redis","slug":"redis","permalink":"http://blog.xmqbeast.com/tags/redis/"}]},{"title":"Redis Lpush命令","date":"2018-05-13T18:28:28.000Z","path":"2018/05/14/Redis-Lpush命令/","text":"Redis Lpush 命令 Redis Lpush 命令将一个或多个值插入到列表头部。 如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。 当 key 存在但不是列表类型时，返回一个错误。 注意：在Redis 2.4版本以前的 LPUSH 命令，都只接受单个 value 值。 语法redis Lpush 命令基本语法如下： redis 127.0.0.1:6379&gt; LPUSH KEY_NAME VALUE1.. VALUEN 返回值执行 LPUSH 命令后，列表的长度。 实例 127.0.0.1:6379&gt; LPUSH list1 &quot;foo&quot; (integer) 1 127.0.0.1:6379&gt; LPUSH list1 &quot;bar&quot; (integer) 2 127.0.0.1:6379&gt; LRANGE list1 0 -1 1) &quot;bar&quot; 2) &quot;foo&quot;","tags":[{"name":"redis","slug":"redis","permalink":"http://blog.xmqbeast.com/tags/redis/"}]},{"title":"Redis Rpoplpush命令","date":"2018-05-13T18:24:57.000Z","path":"2018/05/14/Redis-Rpoplpush命令/","text":"Redis Rpoplpush 命令Redis Rpoplpush 命令用于移除列表的最后一个元素，并将该元素添加到另一个列表并返回。 语法redis Rpoplpush 命令基本语法如下： redis 127.0.0.1:6379&gt; RPOPLPUSH SOURCE_KEY_NAME DESTINATION_KEY_NAME 返回值被弹出的元素。 实例 redis 127.0.0.1:6379&gt; RPUSH mylist &quot;hello&quot; (integer) 1 redis 127.0.0.1:6379&gt; RPUSH mylist &quot;foo&quot; (integer) 2 redis 127.0.0.1:6379&gt; RPUSH mylist &quot;bar&quot; (integer) 3 redis 127.0.0.1:6379&gt; RPOPLPUSH mylist myotherlist &quot;bar&quot; redis 127.0.0.1:6379&gt; LRANGE mylist 0 -1 1) &quot;hello&quot; 2) &quot;foo&quot;","tags":[{"name":"redis","slug":"redis","permalink":"http://blog.xmqbeast.com/tags/redis/"}]},{"title":"Redis Lpop命令","date":"2018-05-13T18:15:07.000Z","path":"2018/05/14/Redis-Lpop命令/","text":"Redis Lpop 命令 Redis Lpop 命令用于移除并返回列表的第一个元素。 语法redis Lpop 命令基本语法如下： redis 127.0.0.1:6379&gt; Lpop KEY_NAME 返回值列表的第一个元素。 当列表 key 不存在时，返回 nil 。 实例 redis 127.0.0.1:6379&gt; RPUSH list1 &quot;foo&quot; (integer) 1 redis 127.0.0.1:6379&gt; RPUSH list1 &quot;bar&quot; (integer) 2 redis 127.0.0.1:6379&gt; LPOP list1 &quot;foo&quot; PS:Redis Rpop 命令用于移除并返回列表的最后一个元素。","tags":[{"name":"redis","slug":"redis","permalink":"http://blog.xmqbeast.com/tags/redis/"}]},{"title":"Redis Llen命令","date":"2018-05-13T18:06:56.000Z","path":"2018/05/14/Redis-Llen命令/","text":"Redis Llen 命令 Redis Llen 命令用于返回列表的长度。 如果列表 key 不存在，则 key 被解释为一个空列表，返回 0 。 如果 key 不是列表类型，返回一个错误。 语法redis Llen 命令基本语法如下： redis 127.0.0.1:6379&gt; LLEN KEY_NAME 返回值列表的长度。 实例 redis 127.0.0.1:6379&gt; RPUSH list1 &quot;foo&quot; (integer) 1 redis 127.0.0.1:6379&gt; RPUSH list1 &quot;bar&quot; (integer) 2 redis 127.0.0.1:6379&gt; LLEN list1 (integer) 2","tags":[{"name":"redis","slug":"redis","permalink":"http://blog.xmqbeast.com/tags/redis/"}]},{"title":"Redis Ltrim命令","date":"2018-05-13T18:01:57.000Z","path":"2018/05/14/Redis-Ltrim命令/","text":"Redis Ltrim 命令 Redis Ltrim 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。下标 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。 语法redis Ltrim 命令基本语法如下： redis 127.0.0.1:6379&gt; LTRIM KEY_NAME START STOP 返回值命令执行成功时，返回 ok 。 实例 redis 127.0.0.1:6379&gt; RPUSH mylist &quot;hello&quot; (integer) 1 redis 127.0.0.1:6379&gt; RPUSH mylist &quot;hello&quot; (integer) 2 redis 127.0.0.1:6379&gt; RPUSH mylist &quot;foo&quot; (integer) 3 redis 127.0.0.1:6379&gt; RPUSH mylist &quot;bar&quot; (integer) 4 redis 127.0.0.1:6379&gt; LTRIM mylist 1 -1 OK redis 127.0.0.1:6379&gt; LRANGE mylist 0 -1 1) &quot;hello&quot; 2) &quot;foo&quot; 3) &quot;bar&quot;","tags":[{"name":"redis","slug":"redis","permalink":"http://blog.xmqbeast.com/tags/redis/"}]},{"title":"redis Lrange命令","date":"2018-05-13T17:49:53.000Z","path":"2018/05/14/redis-Lrange命令/","text":"Redis Lrange 命令 Redis Lrange 返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。 其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。 语法redis Lrange 命令基本语法如下： redis 127.0.0.1:6379&gt; LRANGE KEY_NAME START END 返回值一个列表，包含指定区间内的元素。 实例 redis&gt; RPUSH mylist “one” (integer) 1 redis&gt; RPUSH mylist “two” (integer) 2 redis&gt; RPUSH mylist “three” (integer) 3 redis&gt; LRANGE mylist 0 0 1) “one” redis&gt; LRANGE mylist -3 2 1) “one” 2) “two” 3) “three” redis&gt; LRANGE mylist -100 100 1) “one” 2) “two” 3) “three” redis&gt; LRANGE mylist 5 10 (empty list or set) redis&gt;","tags":[{"name":"redis","slug":"redis","permalink":"http://blog.xmqbeast.com/tags/redis/"}]},{"title":"redis Rpop命令","date":"2018-05-13T17:02:36.000Z","path":"2018/05/14/redis-Rpop命令/","text":"Redis Rpop 命令 Redis Rpop 命令用于移除并返回列表的最后一个元素。 语法redis Rpop 命令基本语法如下： redis 127.0.0.1:6379&gt; RPOP KEY_NAME 返回值列表的最后一个元素。 当列表不存在时，返回 nil 。 实例 redis&gt; RPUSH mylist &quot;one&quot; (integer) 1 redis&gt; RPUSH mylist &quot;two&quot; (integer) 2 redis&gt; RPUSH mylist &quot;three&quot; (integer) 3 redis&gt; RPOP mylist &quot;three&quot; redis&gt; LRANGE mylist 0 -1 1) &quot;one&quot; 2) &quot;two&quot; redis&gt;","tags":[{"name":"redis","slug":"redis","permalink":"http://blog.xmqbeast.com/tags/redis/"}]},{"title":"redis4.0.2配置远程连接（centos7.2）","date":"2018-05-13T16:52:01.000Z","path":"2018/05/14/redis4-0-2配置远程连接（centos7-2）/","text":"最近开始学习redis，在服务器上安装了redis之后，远程连接一直连接不上，报错如下： redis.clients.jedis.exceptions.JedisConnectionException: java.net.ConnectException: Connection refused: connect 总结原因如下：1、6379端口没有开放2.修改redis.conf配置文件 这个文件需要修改两个地方 打开redis.conf文件 按crrl+F查询， 找到bind 127.0.0.1，把这行前面加个#注释掉再查找protected-mode yes 把yes修改为no，然后：wq保存文件，把服务关掉 redis远程连接命令:redis-cli -h 127.0.0.1 -p 6379","tags":[{"name":"redis","slug":"redis","permalink":"http://blog.xmqbeast.com/tags/redis/"}]},{"title":"redis 消息队列(一)","date":"2018-05-13T15:33:43.000Z","path":"2018/05/13/redis-消息队列-一/","text":"Redis队列功能介绍 List 常用命令： Blpop删除，并获得该列表中的第一元素，或阻塞，直到有一个可用 Brpop删除，并获得该列表中的最后一个元素，或阻塞，直到有一个可用 Brpoplpush Lindex获取一个元素，通过其索引列表 Linsert在列表中的另一个元素之前或之后插入一个元素 Llen获得队列(List)的长度 Lpop从队列的左边出队一个元素 Lpush从队列的左边入队一个或多个元素 Lpushx当队列存在时，从队到左边入队一个元素 Lrange从列表中获取指定返回的元素 Lrem从列表中删除元素 Lset设置队列里面一个元素的值 Ltrim修剪到指定范围内的清单 Rpop从队列的右边出队一个元素 Rpoplpush删除列表中的最后一个元素，将其追加到另一个列表 Rpush从队列的右边入队一个元素 Rpushx从队列的右边入队一个元素，仅队列存在时有效 应用场景： Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现。 Lists 就是链表，相信略有数据结构知识的人都应该能理解其结构。使用Lists结构，我们可以轻松地实现最新消息排行等功能。 Lists的另一个应用就是消息队列， 可以利用Lists的PUSH操作，将任务存在Lists中，然后工作线程再用POP操作将任务取出进行执行。Redis还提供了操作Lists中某一段的api，你可以直接查询，删除Lists中某一段的元素。 如果需要还可以用redis的Sorted-Sets数据结构来做优先队列.可以给每条消息加上一个唯一的序号。这里就不详细介绍了。 示意图: 1)入队 2)jedis rpoplpush 具体方法为 /** * Atomically return and remove the last (tail) element of the srckey list, and push the element * as the first (head) element of the dstkey list. For example if the source list contains the * elements &quot;a&quot;,&quot;b&quot;,&quot;c&quot; and the destination list contains the elements &quot;foo&quot;,&quot;bar&quot; after an * RPOPLPUSH command the content of the two lists will be &quot;a&quot;,&quot;b&quot; and &quot;c&quot;,&quot;foo&quot;,&quot;bar&quot;. * &lt;p&gt; * If the key does not exist or the list is already empty the special value &apos;nil&apos; is returned. If * the srckey and dstkey are the same the operation is equivalent to removing the last element * from the list and pusing it as first element of the list, so it&apos;s a &quot;list rotation&quot; command. * &lt;p&gt; * Time complexity: O(1) * @param srckey * @param dstkey * @return Bulk reply */ public String rpoplpush(final String srckey, final String dstkey) RPOPLPUSH source destination 命令 RPOPLPUSH 在一个原子时间内，执行以下两个动作： 将列表 source 中的最后一个元素(尾元素)弹出，并返回给客户端。将 source 弹出的元素插入到列表 destination ，作为 destination 列表的的头元素。举个例子，你有两个列表 source 和 destination ， source 列表有元素 a, b, c ， destination 列表有元素 x, y, z ，执行 RPOPLPUSH source destination 之后， source 列表包含元素 a, b ， destination 列表包含元素 c, x, y, z ，并且元素 c 会被返回给客户端。 如果 source 不存在，值 nil 被返回，并且不执行其他动作。 如果 source 和 destination 相同，则列表中的表尾元素被移动到表头，并返回该元素，可以把这种特殊情况视作列表的旋转(rotation)操作 3） jedis rpop 返回字符串，最后一个元素的值，或者关键不存在返回nil。 /** * Atomically return and remove the first (LPOP) or last (RPOP) element of the list. For example * if the list contains the elements &quot;a&quot;,&quot;b&quot;,&quot;c&quot; RPOP will return &quot;c&quot; and the list will become * &quot;a&quot;,&quot;b&quot;. * &lt;p&gt; * If the key does not exist or the list is already empty the special value &apos;nil&apos; is returned. * @see #lpop(String) * @param key * @return Bulk reply */ public String rpop(final String key) 4) jedis lpush /** * Add the string value to the head (LPUSH) or tail (RPUSH) of the list stored at key. If the key * does not exist an empty list is created just before the append operation. If the key exists but * is not a List an error is returned. * &lt;p&gt; * Time complexity: O(1) * @param key * @param strings * @return Integer reply, specifically, the number of elements inside the list after the push * operation. */ public Long lpush(final String key, final String... strings)","tags":[{"name":"redis","slug":"redis","permalink":"http://blog.xmqbeast.com/tags/redis/"}]},{"title":"凡是你排斥的，就是你所要学习的","date":"2018-03-18T09:55:57.000Z","path":"2018/03/18/凡是你排斥的，就是你所要学习的/","text":"&emsp;&emsp;&emsp; 最近有点迷上了心理学，也许是因为自己本身心理方面有些问题，也希望借此改善自己，所以会去看一些心理学方面的内容。“意识”、“潜意识”，对这些还不是有一个很清晰的了解，从小就一直很羡慕别人的家庭，可能是自己一直得不到家庭的温暖吧，现在老大不小了，并不是很想找个女朋友组个家庭，可能是那个阴影一直在脑海里吧。说这些并不是要怪家人什么，只是希望如果有人跟我有同样的经历，希望能或多或少帮助他们一些。我也一直很想改变自己“潜意识”里面那些不好的东西，所以自己也一直在努力在寻找自己“潜意识”里的那个“我”，希望可以改变“潜意识”里面的那个“我” &emsp;&emsp;&emsp; 法则一：【从外在看内在，从别人看自己】透过别人，你才能认识真正的自己，你从别人身上看到的其实是自己。我们对别人的意见，主要是取决于他们使我们看清自己什么，而不是我们如何看他们。你所有的人际关系都是一面镜子，透过它们，你才能认识真正的自己。你在发觉对方的过程中，不知不觉你也等于是在发掘自己。去了解他的感觉、想法，你也会更了解自己，你们相互成为对方的镜子。如果你觉得伴侣对你失去热情，可能是因为你也对他失去热情；就像一位婚姻专家说的：「如果我们的婚姻变得乏味，可能是因为我觉得乏味，或更糟的是我这个人很乏味。」 事实上，那些令你厌恶的人是在帮助你，他帮助你了解自己，让你发觉你的阴暗面。这也就是为什么当我们跟一个人越亲密，就越容易产生厌恶，因为他让你看到了自己 的真面目。别人最惹你讨厌的地方，通常也是你自己最受不了的地方。 &emsp;&emsp;&emsp; 法则二：【你是什么样的人，就会认为别人是什么样】 你不能容忍他人的部分，就是不能容忍自己的部分。一个品德不好的人，就会怀疑别人的品德；一个对别人不忠诚的人，也会怀疑别人对他的忠诚；一个不正直、不正经的人，就会把别人的任何举动都「想歪」，因为他就是那样的人。一个对的女人有非分之想的人，自然而然地，也会猜疑自己的女人。老遇到讨厌的事的，往往是令人讨厌的人。喜欢挑人毛病的人，其实自己才是最有毛病；喜欢说三道四的人，其实自己才是最不三不四。如果你很爱发脾气，你就会认为别人经常惹你生气，每一件事都可能变成你愤怒的理由。并不是说每一样东西都是错的，而是你会投射，你会把隐藏在自己内在的东西投射到别人身上。你会谴责每一个人、每一件事，因为你有太多的怒气，所以即使是一点小事也能引燃怒火。同样，别人对你说什么，也反映了他们是谁及他们的内心世界。他们批评你很可能是因为他们对自己的不满，甚至他们自己就是他们所批评的「那种人」。当你的内心走向良善时，你将停止批评别人和对别人的批评产生反弹。如果你对一颗长满苹果的树丢石头，掉下来的就只会是苹果，不管谁丢都一样。一个真正良善的人，不管你对他怎么样，他显现出来的就只会是平和、良善，因为他就是那样的人。 &emsp;&emsp;&emsp; 法则三：【你内在是什么，就会被什么样的吸引】你对外排斥什么，对内就排斥什么。一般而言，那些我们相处愉快的人，正是反映了我们喜欢且接受的内在自我；而那些我们不喜欢的人，也反映我们不愉快且不接受内在的自我。教双方和谐相处，不如教他们让自己内心和谐，那样双方自然会和谐；教他们如何增进彼此感情，还不如教他们增进自我成长，那样彼此关系自然会成长。当有人问我要如何改善关系，我总会告诉他们：「首先你要深入内在，除非你内在的问题先解决，否则你不但无法改善，而且会制造更多问题。」 一个有控制欲的人，除非内在的空虚得到填补，否则就不可能停止怨怼；一个爱嫉妒的人，除非内在能找到自信，不再跟人比较，否则就不可能嫉妒。每个人外在的言行举止都是内在思想的呈现。你如果无法信任自己，就很难信任别人；你如果无法尊重自己，就很难尊重别人；你如果无法肯定自己，就很难肯定别人；你如果不能照亮自己，就不可能照亮别人。当伴侣们没有了爱而彼此伤害，我不会告诉他们要如何努力爱对方，而是要求他们先学会爱自己，因为伤害对方其实就是在伤害自己。你与每个人的关系，都反映出你与自己的关系。如果你不断与自己的内在冲突，那么你也会不断地与别人冲突；如果你自己内在的情感挣扎，那么你也会与别人在情感上发生挣扎。我们在感情中所遭遇的问题，就是我们内在的问题。我们吸引的关系，都反映出我们拥有的特质，以及呈现我们的内在自我。所以，关系出问题的人，不仅要检讨你跟别人的关系，也要反省你跟自己的关系。 以下是一些可以自我检视的问题：「当我观察你所反映的我，我感到ˍˍˍˍˍ。」（诸如愤怒、恐惧、失控、困惑之类的感受。）「你反映了我的哪个自我？」 「外在」困扰我们的问题，正是我们「内在」无法整合的部分。 如果你想改善外在的一切，就必须从改变内在开始。 &emsp;&emsp;&emsp; 法则四：【你约束别人，自己也会被约束】 你越恨就越束缚，你越爱就越自由。当你掌控别人时，你同时也被掌控；如果你绑住别人，别人也会绑住你。你想想看，当你控制别人，不准他们做这做那个，那如果他们不按照你说的话去做呢？你会怎么样？你就会不高兴，对吗？你的喜怒哀乐是由别人来决定，你认为他们是被你掌控的吗？不，其实你才是被掌控的。以眼还眼，结果是大家都瞎了。如果你不断在记忆中反刍旧伤痛，你就是给了最初导致伤痛的人、事一再伤害你的力量。当你怨恨别人时，表示某种程度上，你也怨恨自己。要怎么彻底消灭敌人？把敌人变成朋友！你就会发现，那些最难得到原谅的人，正是你最需要原谅的人；最难放手的人，正是你最需要放手的人。 &emsp;&emsp;&emsp; 法则五：【如果你很排斥，它就是你必须学习的课题】 如果你很欣赏，它就可以蜕变成爱。我们的主要的人际关系，不断地反映该学习的课题是什么。无论是你的老板、同事、朋友、情人、配偶或小孩皆然，这些人所拥有的你所不喜欢的个性、想法和行为，往往都是你需要学习的部分。他们会显露你的阴影，会一再地重复你所厌恶的言行来让你学习。当有人指出你的错误，你很气那个，但这是他的错吗？不，他只是帮你把「发霉的阴影」拿出来晒晒太阳。你不会因为别人说你想偷窃海洋馆的一只鲸鲨而冒火，因为那是你连想都不会想做的事。但是，如果你太太说你旅游出差是想借机去「偷腥」，你可能就会辩驳，甚至发火。为什么？因为这种事有可能发生，或曾经甚至已经发生了。没错，一般而言，越接近事实的指控，你越有可能起而辩护和发火。 所以，以后当别人指责你的时候，不要再像以前一样，立刻去攻击或反击，你要开始反问自己，因为他们说的很可能是真的。 如果不是真的，你又何必那么「当真」，对吗？ 他们之所以会安排在你身边，都是「有原因」的。 因此，不要说不喜欢就排斥或试图逃避他们，因为他们都是「天赐的良缘」，你应该好好利用这个机缘来蜕变自己。 去爱一个喜欢你的人，没什么了不起。 去爱一个爱你的人，你什么分数也得不到。 去爱一个你不喜欢的人，你一定会在生命中学到一些东西。 去爱一个无缘无故责备你的人，你就学到了生命的艺术。 ——印度大师古儒吉 爱是什么？ 爱就是欣赏你不喜欢和不爱的。 如果在你生活周遭有太多你讨厌或不爱的人事物，那是因为你一直在排斥，所以他们才会一再出现，你必须学会​​生活的艺术——将它们蜕变成爱。","tags":[]},{"title":"关于融资","date":"2018-03-11T16:23:16.000Z","path":"2018/03/12/关于融资/","text":"&ensp;&ensp;&emsp; 一直在想一些关于创业的事情，最近炒的很火的比特币、区块链技术、去中心化等等，也许现在的社会是有点浮躁了，每个人都想快速增加自己的财富，所以造成一大堆人的赌博、跟风心理。可能过了30岁这个槛，我现在也有点这种心理，可能是技术出身，所以也不太会去赌博，还是希望在新的一年里能静下心来好好专研技术。最近在面试，跟面试官聊了一些创业的东西，感觉还是不错的，淘宝、支付宝能成功，是因为他们解决了买家跟卖家的信任问题，淘宝网购确实给社会带来了很大便利，也解决了很多社会问题，就业、商品的销售渠道等等。我觉得，如果能解决信任问题，就可以做成很多买卖，就跟滴滴的私家车一样，解决了车主跟乘客的信任问题，同时也给社会创造了价值，让跑私家车的司机可以多赚点家用补贴，还是非常了不起的。但是话说回来，做平台也并不是那么容易的，需要大众的信任，因为很多平台也是做到一半就跑路，所以让人信任也不是一件容易的事儿。 &ensp;&ensp;&emsp; 刚看到一篇融资的文章，写的还不错，如果有一天，能自己创业，拿到投资或者融资的钱，一定会尽心尽力去做，当前应该做一些比较实际的东西，比如说做好技术、锻炼身体、好好爱自己等等。","tags":[]},{"title":"七秒钟的记忆","date":"2018-03-11T06:36:48.000Z","path":"2018/03/11/七秒钟的记忆/","text":"&ensp;&ensp;&emsp; 一直在思考一些心理、行为，可能自己有一些心理或精神上的缺失，所以有时候会比较想去研究这些东西。活了30多年，也许之前自己是一直处于比较迷茫的，但是也一直在很努力寻找努力的方向。这些话看起来很老套，有点像心灵鸡汤的东西，但人确确实实是需要目标或者理想的。慢慢发现，自己对那些美好的文字、音乐、电影等艺术算是比较感兴趣，假如自己的职业不是一个程序员，可能会去搞艺术或者当一名运动员，因为自己也算是比较喜欢运动的，然而这艺术跟运动的门槛比当一名程序员高得多，所以暂时也没有想换行业的想法，还是会花大部分精力在写代码上面。 &ensp;&ensp;&emsp; 写这些东西可能是因为做一个总结吧，刚过完农历的新年，算是一个新的开始吧。最近在看一本叫《心流》的心理学相关方面的书，里面有说到，我们接收到的每一条资讯，都要经过自我的批判。它对我们的目标是威胁、支持，还是完全中立？股市下跌的消息往往令银行家担忧，但对政治异议分子却可能是振奋人心的好消息。一条新资讯可能会使我们付出所有心力应付威胁，造成意识的失序；但它也可能强化我们的目标，激发出更多的精神能量。 &ensp;&ensp;&emsp; 当我们发觉收到的资讯与目标亲和，精神能量就会源源不断，没有担心的必要，也无须猜疑自己的能力。我们不再怀疑自己，只因为我们得到了明确的鼓励：“你做得很好！”积极的反馈强化了自我，使我们能投入更多的注意力，照顾内心与外在环境的平衡。最优体验出现时，一个人可以投入全部的注意力，以求实现目标；没有失序现象需要整顿，自我也没有受到任何威胁，因此不需要分心防卫。我们称它为“心流体验”，处于最优状态时的感觉：“好像漂浮起来”，“一股洪流带领着我”。它正好是精神熵的反面————实际上，有时候我们称它为“精神负熵”。拥有它的人就能培养一股更坚强、更自信的自我，能够用更多的精神力量，专注于自己选择的目标。 &ensp;&ensp;&emsp; 一个人若能充分掌控意识，尽可能创造心流体验，生活品质势必会提高。即使是平凡无奇地例行公事，经过自我转换，也变得有方向、有乐趣。在心流中，我们是精神力量的主宰，无论做什么事都能使意识更有秩序。以下是一名知名攀岩专家的心流体验： 越来越完美的自我控制，产生一种痛快的感觉 你不断逼身体发挥所有的极限，直到全身隐隐作痛 然后你会满怀敬畏地回顾自我，回顾你所做的一切，那种佩服的感觉简直无法形容 它带给你一种狂喜，一种自我满足 只要在这种战役中战胜过自己，人生其他战场的挑战，也就变得容易多了 &ensp;&ensp;&emsp; 其实战斗中对抗的不是自己，而是使意识失序的精神熵。我们是为保卫自我而战，这同时也是一场控制注意力的斗争，虽然它不一定像攀岩那样涉及到体能的挑战。体验过心流的人都知道，那份深沉的快乐是严格的自律、集中注意力换来的。 &ensp;&ensp;&emsp; 在心流状态下，意识全神贯注、秩序井然，有助于自我的整合。思想、企图、感觉和所有的感官都集中于同一个目标上，自我体验也臻于和谐。当心流结束时，一个人会觉得，内心和人际关系都比以前更“完整”。前面提到的那位攀岩专家还说：“爬山是激发一个人全部能力的最佳活动。没有人会逼迫你，能否爬上巅峰对身心不构成压力，你有很多志同道合的同伴在旁边，大家都齐心协力。还有谁比这些人更值得信赖呢？他们跟你同样追求自律，全心全意投入，跟这些人建立这样的关系，本身就是最大的喜悦” &ensp;&ensp;&emsp; 我们只有在不掺杂其他动机，只为行动而行动时，才能学会做一个比原来的自己更复杂的人。选定一个目标，投入全部的注意力，不论做什么事都会觉得乐趣无穷。一旦尝到这种快乐，我们就会加倍努力，重温它的滋味————自我就这样开始成长了。","tags":[{"name":"psychology","slug":"psychology","permalink":"http://blog.xmqbeast.com/tags/psychology/"}]},{"title":"在关系中遇见自己","date":"2018-03-10T13:43:39.000Z","path":"2018/03/10/在关系中遇见自己/","text":"&emsp; &emsp; 人的一生中，我们会遇到很多人，建立多种不同的人际关系：亲子关系、夫妻关系、婆媳关系、同事关系、朋友关系等，在这种种关系中，你会有不同的角色和感受，激情、亲密、压抑、苦恼、愤怒等等，每一种情绪背后都藏着你的渴求。","tags":[]},{"title":"做一个拥有好习惯的人","date":"2018-03-10T13:17:29.000Z","path":"2018/03/10/做一个拥有好习惯的人/","text":"思想决定行为，行为决定习惯，习惯决定性格，性格决定命运。 如果你想问习惯是什么？大卫-休谟会告诉你：“习惯是人生的伟大指导”。习惯的力量有多大？既不能被经验证明，也不能被经验证伪，能够说明的只有概率，做得多了，时间长了，习惯了也就成自然了。 习惯是一种长期的思维方式、处世态度，习惯是由一而再、再而三的思想行为形成的，习惯具有很强的惯性，跟转动的车轮一样。 人们往往会不由自主地启用自己的习惯，不论是好习惯还是不好的习惯，都是如此，可见习惯在不经意间会影响一个人的一生。但是坚持一个好的习惯却很难，比如坚持每天跑5公里，坚持每天背20个单词，坚持每个月看1本书等。这些习惯一旦养成，你会收获一个健康的身体、记住7300个单词，看12本书等等，也许你的生活也会就此改变。","tags":[]},{"title":"在 Markdown 语言中，如何实现段首空格的显示 ","date":"2018-03-09T15:47:36.000Z","path":"2018/03/09/在-Markdown-语言中，如何实现段首空格的显示/","text":"直接写 半方大的空白‘&amp;ensp’;或‘&amp;#8194’; 全方大的空白‘&amp;emsp’;或‘&amp;#8195’; 不断行的空白格‘&amp;nbsp’;或‘&amp;#160’; 两个‘&amp;emsp’;即可 ‘&amp;nbsp’;//半角空格（英文） ‘&amp;emsp’;//全角空格（中文）","tags":[]},{"title":"hexo d -g 后出现验证报错verification failed","date":"2018-03-09T15:41:07.000Z","path":"2018/03/09/hexo-d-g-后出现验证报错verification-failed/","text":"验证报错报错verification failed：Error: Host key verification failed.fatal: Could not read from remote repository.Please make sure you have the correct access rights and the repository exists. 解决方法：条件SSHkey$ ssh-keygen -t rsa -C “imsofter@163.com“三次回车，即可设置密码为空 将生成的C:\\Users\\Administrator.ssh目录下的id_rsa.pub添加到github上 再ssh git@github.com Hi imsofter! You’ve successfully authenticated, but GitHub does not provide shell access.Connection to github.com closed. 再可以将代码推上github上了。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://blog.xmqbeast.com/tags/hexo/"}]},{"title":"关于开源","date":"2018-03-09T00:58:45.000Z","path":"2018/03/09/关于开源/","text":"&emsp;&emsp;一直很想做一些开源的东西，做了几年了java后端的相关工作，一直很佩服也很欣赏spring的那些开源项目，大到银行、电商，小到一些初创公司的项目，基本中间件都是用spring，无一例外。自己也从开源社区github学到非常多的东西，所以，接下来的重心会放在写一些技术博客上。互联网催生了一大批程序员，这也是我what i make a living。 &emsp;&emsp;其实可能自己从小缺少关爱等其他一些因素，导致现在的我三观跟大多数人并不太一样，自己也一直很努力在调整，希望可以被大众接受。自己业余时间也看了很多心理学、生理学、哲学方面的东西，也许在外人看起来是一些心灵鸡汤的，但是我觉得这些是科学，有机会也希望可以分享给大家，虽然也不知道自己写的东西会不会被看到，但是还是希望可以帮助到一些需要帮助的人。这也是我热衷于开源的一个原因 &emsp;&emsp; 现在这个社会因为信息不对称，催生了很多商业的东西，也许那就是商业的本质，但自己其实更感兴趣的是一些可以为社会创造价值的东西，一直找不到入口去创业，所以会把更多精力花在开源的东西上面。这段时间思考更多的可能是生与死、善与恶、天使与魔鬼这些东西，可能自己或多或少有点抑郁症，有时候确实情绪非常低落的时候，会想离开这个世界。因为害怕自己变成一个坏人，所以一直告诉自己不管做什么，一定要善良。很高兴，自己没有变成坏人，希望日后可以变成一个对社会有用的人，也会尽自己一份最大的努力去做","tags":[{"name":"opensource","slug":"opensource","permalink":"http://blog.xmqbeast.com/tags/opensource/"}]},{"title":"Hello World","date":"2018-03-08T15:55:02.736Z","path":"2018/03/08/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"How to set the max size of upload file","date":"2017-11-19T08:06:19.000Z","path":"2017/11/19/How-to-set-the-max-size-of-upload-file/","text":"I’m developing application based on Spring Boot and AngularJS using JHipster. My question is how to set max size of uploading files? If I’m trying to upload to big file I’m getting this information in console DEBUG 11768 --- [io-8080-exec-10] c.a.app.aop.logging.LoggingAspect: Enter: com.anuglarspring.app.web.rest.errors.ExceptionTranslator.processRuntimeException() with argument[s] = [org.springframework.web.multipart.MultipartException: Could not parse multipart servlet request; nested exception is java.lang.IllegalStateException: org.apache.tomcat.util.http.fileupload.FileUploadBase$FileSizeLimitExceededException: The field file exceeds its maximum permitted size of 1048576 bytes.] Also in Spring boot 1.4, you can add following lines to your application.properties to set the file size limit: spring.http.multipart.max-file-size=128KB spring.http.multipart.max-request-size=128KB There is some difference when we define the properties in the application.properties and application yaml. In application.yml : spring: http: multipart: max-file-size: 256KB max-request-size: 256KB And in application.propeties : spring.http.multipart.max-file-size=128KB spring.http.multipart.max-request-size=128KB","tags":[{"name":"spring","slug":"spring","permalink":"http://blog.xmqbeast.com/tags/spring/"}]},{"title":"错过的爱","date":"2017-11-10T00:31:33.000Z","path":"2017/11/10/错过的爱/","text":"one day 这部改编自英国作家大卫·尼克尔斯的同名小说《一天》,男女主角是大学同学，毕业时才相识，在一夜缠绵后分开，决定每年的一天，都要见面聊聊彼此近况。 男主角家境不错，身边不乏女人围绕，而女主角是工人家庭出生，努力工作努力生活。 他们各自经历了生活和爱情，他们当了23年的好朋友，却没有真正意义上的在一起过。 她一直爱他，不论他的新是否在她这里，不论他变得如何堕落庸俗，如何自私懦弱，她还是爱他。 在不断的离别与交汇后，男主角终于明白，soulmate其实就在身边。 但好景不长，女主角因一场车祸去世，两人的感情戛然而止，终究还是错过了。 就像影片中所言：”不管明天发生什么，把握好今天“ 如果真的喜欢一个人，请告诉ta,无论结果如何，至少不会在未来的日子里遗憾。","tags":[{"name":"情感","slug":"情感","permalink":"http://blog.xmqbeast.com/tags/情感/"}]},{"title":"马斯洛需求层次理论","date":"2017-11-07T19:19:22.000Z","path":"2017/11/08/马斯洛需求层次理论/","text":"马斯洛将人的需求层次分为五个层次。分别是： 一、生理需求。它是指人类生存最基本的需求。比如衣、食、住、行。例如一个经常处于饥饿状态的人，首先需要的是食物，为此，他的生活目的被看成是填饱肚子。当基本的生理需求得到满足之后，生理需求就不再是推动人们工作的最强烈动力，取而代之的是安全需求。 二、安全需求。安是指保护自己的身体和情感免受伤害的需求。这种安全需求体现在生活生活中是多方面的，比如说生命安全，劳动安全，良好的社会环境。反映在工作环境中，员工希望能够避免危险事故，保障人身安全，避免事业等等。 三、社会需求。它包括友谊、爱情、归属，信任和接纳。马斯洛认为，人是一种社会动物，人们的生活和工作都不是独立进行的，经常会与他人接触，因此人们需要社会交往，良好的人际关系，人与人之间的感情还有爱，在组织中能够得到他人的接纳和信任。 四、尊重需求。它包括自尊和受到他人尊重两方面。自尊是指自己的自尊心，工作努力不甘落后，有充分的自信心，以及获得成就后的自豪感。受人尊重是指自己的工作成绩，社会地位能够得到他人的认可。这一需求可概括为自尊心、自信心、威望、社会地位等方面的需求。 五、自我实现的需求。它是指个人的成长和发展，发挥自身潜能，实现理想的需求。简单来说就是梦想的实现。","tags":[{"name":"心理","slug":"心理","permalink":"http://blog.xmqbeast.com/tags/心理/"}]},{"title":"关于经历","date":"2017-11-04T00:23:43.000Z","path":"2017/11/04/关于经历/","text":"如果你曾经玩过角色扮演类的RPG游戏，你就会知道有一个概念叫EXP，全称叫Experience,这就是经历的英文。人的一生就是一场巨大的RPG,你扮演着你自己。你唯一升级的方法，就是不断地积累EXP. 我们都了解那些故事，我们都懂那些道理，看了那么多励志贴，我们甚至都快知道为什么乔布斯会成为乔布斯。但只有经历才能让我们把那些道理变成意识。那些改变我们一生的道理，都不是别人教会的。 在人生的每个阶段，只有我们已经拥有的那些经历，决定了我们下一步会去做什么。所以很多时候，你只要记得一件事，那就是：去体验不同的经历。去爱，去恨，去在热恋中没心没肺地笑，去在失恋后嘶声力竭地哭，去翘课，去打架，去拼了命的读书，去让自己真的领悟那些道理。你所尝试的事，你所认识的人，都是你经历的一部分。他们会帮助你去理解你一直知道但是不曾真正理解的事，他们会帮助你看到一直存在着但是你不曾看到的世界。 你的人生很短，你的时间货币只有那么多。所以除了乔布斯已经告诉你的“不要活在别人的世界里”，你还要记得，永远不要重复一样的经历，因为你不会从第二次一样的经历中收获到更多，更因为这个偌大的世界有着太多有趣的人等着我们去认识、太多截然不同的经历等着我们去体验。 你只要记住，如果你每个星期都在做着差不多的事情，那么一年以后你还是一年前的你，只是老了一岁。如果你愿意每个星期、或者每个月都去尝试一种新的体验，或者认识一个来自完全不同背景的朋友，那么一年后你和一年前一样年轻，只是比别人多活了一年，多了一年的阅历还有对这个世界的认知。","tags":[{"name":"情感","slug":"情感","permalink":"http://blog.xmqbeast.com/tags/情感/"}]},{"title":"关于是否会为了去经历、去追随感情和理想而后悔","date":"2017-11-03T00:40:22.000Z","path":"2017/11/03/关于是否会为了去经历、去追随感情和理想而后悔/","text":"每个人都会有后悔的经历，但是我们一定不会为了作出追求感情、或者追随理想的决定而后悔。 事实是，如果我们有努力追寻、不愿放弃的梦想，如果我们有深爱的、不想伤害的人，那么在这条道路上，我们一定会为我们曾经做过的某些事而后悔。当我们离理想或者真爱越是近，我们越是容易后悔。举个例子，晚一分钟错过飞机的人会比晚一个小时错过飞机的人更加后悔懊恼，因为我们心里很清楚如果自己不曾犯下某些错误，如果我们再多那么一点点坚持，或许早就已经实现了梦想。 其实后悔只是一个信号，它告诉我们，离目标已经很近了。更重要的是，我们活着并不是为了追求什么“无悔的生活”，我们不必为了那些后悔而伤心痛苦。因为在我们选择的这条道路上，后悔并不是为了告诉我们曾经做错了什么，而是想要告诉我们怎么做可以做得更好。","tags":[{"name":"情感","slug":"情感","permalink":"http://blog.xmqbeast.com/tags/情感/"}]},{"title":"linux下配置网络静态ip","date":"2017-11-02T09:44:08.000Z","path":"2017/11/02/linux下配置网络静态ip/","text":"linux下配置网络静态ip vi /etc/sysconfig/network-scripts/ifcfg-eth0 service network restart 或/etc/init.d/network restart DEVICE=eth0（设备名称） HWADDR=00：0c:29：d3:bb:e5 (mac地址) TYPE=Ethernet （网络类型） ONBOOT=yes (开机启动) BOOTTPROTO=static （静态ip） DNS1：192.168.1.1 (dns) IPADDR=192.168.1.45 （ip地址） NETMASK=255.255.255.0 (子网掩码) GATEWAY=192.168.1.1 （网关） 如果ping的是广域网而不是局域网，还要确保网关和DNS正确，用命令route add default gw 192.168.1.1","tags":[{"name":"linux","slug":"linux","permalink":"http://blog.xmqbeast.com/tags/linux/"}]},{"title":"关于冰山模型","date":"2017-11-01T17:51:05.000Z","path":"2017/11/02/关于冰山模型/","text":"人类为何有人【小富即安】，而有人有【鸿鹄之志】呢？ 这里有两个问题： 1.为什么会有动机的产生？ 2.动机为什么会有所不同? 我们从冰山模型说起，可能学心理学或者人力资源的人会知道一些。 模型表达的核心意思有两点： 1.人类表现出来的知识和技能只是冰山的一角，决定自身综合素质的是冰山下面的部分：价值观、自我认知、品质、动机。 2.冰山以上相对好建设，冰山以下部分，相对难以改变。 这就是冰山模型，由美国著名的心理学家麦克利兰在1973年提出的一个著名模型，所谓“冰山模型”，就是将人员个体素质的不同表现表式划分为表面的“冰山以上部分”和深藏的“冰山以下部分”。 模型结构如下图展示： 以上，从上到下，改变难度越来越大，被感知的难度也越来越大。技能比知识好学，价值观虽然难改变，但是也可以被调整或者自我调整，而最底层的“动机”的形成，现在普遍认为只和基因及童年因素有关，几乎无法改变。所以现在有些理论认为冰山模型最下面应该还有一层基因，我们暂时就不说了。 层次划分： 1、知识，指个人在某一特定领域拥有的事实型与经验型信息 2、技能，指结构化地运用知识完成某项 具体工作的能力,即对某一特定领域所需技术与知识的掌握情况 3、社会角色，指一个人基于态度和价值观的行为方式与风格 4、自我概念，指一个人的态度、价值观和自我印象 5、特质（性格），指个性、身体特征对环境和各种信息所表现出来的持续反应。品质与动机可以预测个人在长期无人监督下的工作状态。 6、动机，指在一个特定领域的自然而持续的想法和偏好（如成就、亲和、影响力），它们将驱动，引导和决定一个人的外在行动。 其中第1、2项大部分与工作所要求的直接资质相关，我们能够在比较短的时间使用一定的手段进行测量。可以通过考察资质证书、考试、面谈、简历等具体形式来测量，也可以通过培训、锻炼等办法来提高这些素质。 第3、4、5、6项往往很难度量和准确表述，又少与工作内容直接关联。只有其主观能动性变化影响到工作时，其对工作的影响才会体现出来。考察这些方面的东西，每个管理者有自己独特的思维方式和理念，但往往因其偏好而有所局限。管理学界及心理学有着一些测量手段，但往往复杂不易采用或效果不够准确。","tags":[{"name":"情感","slug":"情感","permalink":"http://blog.xmqbeast.com/tags/情感/"}]},{"title":"卢巧音唱的三角志歌词所代表的含义","date":"2017-10-31T10:25:04.000Z","path":"2017/10/31/卢巧音唱的三角志歌词所代表的含义/","text":"这首歌应该说的是一个女生爱上了一个男生,但是这个男生特别特别花心,这个女生不止一次的发现男生和别的女生有问题,有一天这个女生又发现了这个男生和另一个女生之间的事情,并没有揭穿他,应为她知道,即使揭穿他这一次,仍有下一次.也许当初这个女生也是以第三者的身份和这个男生在一起的,在一起之后发现这个男生的花心,于是这个女生就彻底的看透了这个男生,决定洒脱放手,因为她知道,不放手还有第四者、第五者,即使这个男生这次回到他身旁,仍会有下一次.爱情如果存在三人之间的战争,不管输赢其结果都是伤痕累累.爱上这种花心男是不存在好心有好报的,温柔、善良、妥协都根治不了这种病,也许会一时好转,但总有一天会复发…即使曾在一起再温馨、拥有再美好的回忆终究不会拥有永恒,也许他爱你,但他不会只爱你,更不会永远爱你… 这就是我对这首歌的理解","tags":[{"name":"情感","slug":"情感","permalink":"http://blog.xmqbeast.com/tags/情感/"}]},{"title":"喵喵和小煤球","date":"2017-10-28T15:24:07.000Z","path":"2017/10/28/喵喵和小煤球/","text":"","tags":[]},{"title":"redis简单介绍及安装（linux）","date":"2017-10-24T16:39:50.000Z","path":"2017/10/25/redis简单介绍及安装（linux）/","text":"redis是当前比较热门的NOSQL系统之一，它是一个key-value存储系统。和Memcached类似，但很大程度补偿了memcached的不足，它支持存储的value类型相对更多，包括string、list、set、zset和hash。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作。在此基础上，redis支持各种不同方式的排序。Redis数据都是缓存在计算机内存中，并且会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。 redis官网地址：http://www.redis.io/ 最新版本：2.8.3 在Linux下安装Redis非常简单，具体步骤如下（官网有说明）： 1、下载源码，解压缩后编译源码。 $ wget http://download.redis.io/releases/redis-2.8.3.tar.gz $ tar xzf redis-2.8.3.tar.gz $ cd redis-2.8.3 $ make 2、编译完成后，在Src目录下，有四个可执行文件redis-server、redis-benchmark、redis-cli和redis.conf。然后拷贝到一个目录下。 mkdir /usr/redis cp redis-server /usr/redis cp redis-benchmark /usr/redis cp redis-cli /usr/redis cp redis.conf /usr/redis cd /usr/redis 3、启动Redis服务。 $ ./redis-server redis.conf 4、然后用客户端测试一下是否启动成功。 $ redis-cli redis&gt; set foo bar OK redis&gt; get foo &quot;bar&quot;","tags":[{"name":"redis","slug":"redis","permalink":"http://blog.xmqbeast.com/tags/redis/"},{"name":"linux","slug":"linux","permalink":"http://blog.xmqbeast.com/tags/linux/"}]},{"title":"从你的全世界路过","date":"2017-10-22T08:37:40.000Z","path":"2017/10/22/从你的全世界路过/","text":"从你的全世界路过 总有几分钟，其中的每一秒，你都愿意拿一年去换取。 总有几颗眼泪，其中的每一次抽泣，你都愿意拿满手的承诺去代替。 总有几段场景，其中的没幅画面，你都愿意拿全部的力量去铭记。 总有几句话，其中的每个字眼，你都愿意拿所有的夜晚去复习。","tags":[{"name":"情感","slug":"情感","permalink":"http://blog.xmqbeast.com/tags/情感/"}]},{"title":"mysql 'root'@'localhost'无法登录","date":"2017-10-22T03:43:05.000Z","path":"2017/10/22/mysql-root-localhost-无法登录/","text":"MySQL ‘root‘@’localhost’无法登录 #mysql -u root -p 提示”Access denied for user ‘root’@’localhost’ (using password: YES)” 远程可以登录，本地不能登录，原因是没有授权本地登录，使用命令 select Host,User,Password from mysql.user; 使用命令： grant all privileges on dbName.* to &apos;root&apos;@&apos;localhost&apos; identified by &apos;123456&apos; with grant option; flush privileges ;","tags":[{"name":"mysql","slug":"mysql","permalink":"http://blog.xmqbeast.com/tags/mysql/"}]},{"title":"hexo添加搜索服务","date":"2017-10-14T18:11:26.000Z","path":"2017/10/15/hexo添加搜索服务/","text":"在hexo-&gt;NexT主题下添加搜索服务 NexT 支持集成 Swiftype、 Local Search 和 Algolia。 1.安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： $ npm install hexo-generator-searchdb --save 2.编辑 站点配置文件，新增以下内容到任意位置： search: path: search.xml field: post format: html limit: 10000 3.编辑 主题配置文件，启用本地搜索功能： # Local search local_search: enable: true 另外介绍其他两个插件 一、给博客添加feed 1.安装hexo-generator-feed $ npm install hexo-generator-feed –save 2.配置到站点配置文件_config.yml # Extensions ## Plugins: http://hexo.io/plugins/ #RSS订阅 plugin: - hexo-generator-feed #Feed Atom feed: type: atom path: atom.xml limit: 20 3.最后，在你next主题下的_config.yml下，添加RSS订阅链接即可： rss: /atom.xml 二、给博客生成一个站点地图 1.安装hexo-generator-seo-friendly-sitemap $ npm install hexo-generator-seo-friendly-sitemap --save 2.在站点配置文件_config.yml 中添加 sitemap: path: sitemap.xml","tags":[{"name":"hexo","slug":"hexo","permalink":"http://blog.xmqbeast.com/tags/hexo/"}]},{"title":"npm install项目出错解决方法","date":"2017-10-11T18:54:36.000Z","path":"2017/10/12/npm-install项目出错解决方法/","text":"108629 error Windows_NT 10.0.10586 108630 error argv &quot;D:\\\\Program Files\\\\nodejs\\\\node.exe&quot; &quot;D:\\\\Program Files\\\\nodejs\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js&quot; &quot;install&quot; 108631 error node v5.6.0 108632 error npm v3.6.0 108633 error code ELIFECYCLE 108634 error phantomjs@1.9.19 install: node install.js 108634 error Exit status 1 108635 error Failed at the phantomjs@1.9.19 install script &apos;node install.js&apos;. 108635 error Make sure you have the latest version of node.js and npm installed. 108635 error If you do, this is most likely a problem with the phantomjs package, 108635 error not with npm itself. 108635 error Tell the author that this fails on your system: 108635 error node install.js 108635 error You can get information on how to open an issue for this project with: 108635 error npm bugs phantomjs 108635 error Or if that isn&apos;t available, you can get their info via: 108635 error npm owner ls phantomjs 108635 error There is likely additional logging output above. 108636 verbose exit [ 1, true ] 解决方法： 删除npmrc文件，使用镜像 npm iconfig set registry http://registry.cnpmjs.org npm info underscore","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://blog.xmqbeast.com/tags/nodejs/"}]},{"title":"hexo博客出现commond not found解决方案","date":"2017-10-11T18:34:35.000Z","path":"2017/10/12/hexo博客出现commond-not-found解决方案/","text":"hexo -v 出现了conmand not found的提示 按照字面上的翻译就是 找不到所使用的命令。我猜想可能是好久没有使用的原因了，于是按照以前的安装教程重新安装了一次安装教程，安装完毕之后，发现还是存在上面的问题，于是去请教大神，先查看各种工具是否都安装好了，在命令行中输入node -v 然后再检查npm -v。 结果发现这里也没有问题。所以就可能是环境变量的问题，这里我突然想起可能是上次配置JAVA环境变量的时候，可能把这个环境变量搞错了，所以这里先去找到这个路径，C:\\Users\\xiaoti\\node_modules\\hexo\\bin ，然后把它添加到环境变量PATH路径的后面。 配置下环境变量，hexo就恢复正常了","tags":[{"name":"hexo","slug":"hexo","permalink":"http://blog.xmqbeast.com/tags/hexo/"}]},{"title":"阿里云服务器CentOS启动tomcat8巨慢的解决方案","date":"2017-10-10T09:29:11.000Z","path":"2017/10/10/阿里云服务器CentOS启动tomcat8巨慢的解决方案/","text":"摘要： 自己再阿里云申请了一台1G1核的机器，每次重启自己的服务tomcat都需要卡住很长时间 经过在网上搜索，找到了原因： Tomcat 7/8都使用org.apache.catalina.util.SessionIdGeneratorBase.createSecureRandom类产生安全随机类SecureRandom的实例作为会话ID，这里花去了342秒，也即接近6分钟。 自己再阿里云申请了一台1G1核的机器，每次重启自己的服务tomcat都需要卡住很长时间经过在网上搜索，找到了原因： Tomcat 7/8都使用org.apache.catalina.util.SessionIdGeneratorBase.createSecureRandom类产生安全随机类SecureRandom的实例作为会话ID，这里花去了342秒，也即接近6分钟。 SHA1PRNG算法是基于SHA-1算法实现且保密性较强的伪随机数生成器。 在SHA1PRNG中，有一个种子产生器，它根据配置执行各种操作。 1）如果Java.security.egd属性或securerandom.source属性指定的是”file:/dev/random”或”file:/dev/urandom”，那么JVM会使用本地种子产生器NativeSeedGenerator，它会调用super()方法，即调用SeedGenerator.URLSeedGenerator(/dev/random)方法进行初始化。 2）如果java.security.egd属性或securerandom.source属性指定的是其它已存在的URL，那么会调用SeedGenerator.URLSeedGenerator(url)方法进行初始化。 这就是为什么我们设置值为”file:///dev/urandom”或者值为”file:/./dev/random”都会起作用的原因。 在这个实现中，产生器会评估熵池（entropy pool）中的噪声数量。随机数是从熵池中进行创建的。当读操作时，/dev/random设备会只返回熵池中噪声的随机字节。/dev/random非常适合那些需要非常高质量随机性的场景，比如一次性的支付或生成密钥的场景。 当熵池为空时，来自/dev/random的读操作将被阻塞，直到熵池收集到足够的环境噪声数据。这么做的目的是成为一个密码安全的伪随机数发生器，熵池要有尽可能大的输出。对于生成高质量的加密密钥或者是需要长期保护的场景，一定要这么做。 那么什么是环境噪声？ 随机数产生器会手机来自设备驱动器和其它源的环境噪声数据，并放入熵池中。产生器会评估熵池中的噪声数据的数量。当熵池为空时，这个噪声数据的收集是比较花时间的。这就意味着，Tomcat在生产环境中使用熵池时，会被阻塞较长的时间。 基本上就是这样，这里讲的更详细！ 下面说解决方式： 网上说： 通过修改Tomcat启动文件-Djava.security.egd=file:/dev/urandom 通过修改JRE中的java.security文件securerandom.source=file:/dev/urandom 这两种方式在我这都失败，不起作用，不知道是我的问题，还是其他问题。 最终解决方式： yum install rng-tools安装rngd服务（熵服务） systemctl start rngd启动服务 如果你的CPU不支持DRNG特性或者像我一样使用虚拟机，可以使用/dev/unrandom来模拟。 cp /usr/lib/systemd/system/rngd.service /etc/systemd/system 编辑/etc/systemd/system/rngd.service service小结，ExecStart=/sbin/rngd -f -r /dev/urandom systemctl daemon-reload重新载入服务 systemctl restart rngd重启服务 这样安装了熵服务后问题就解决了，Tomcat启动又回到了以往的速度。","tags":[{"name":"centos","slug":"centos","permalink":"http://blog.xmqbeast.com/tags/centos/"}]},{"title":"Vue2.0入门","date":"2017-10-09T16:50:40.000Z","path":"2017/10/10/Vue2-0入门/","text":"","tags":[]},{"title":"linux下修改防火墙配置重启命令","date":"2017-10-09T10:12:08.000Z","path":"2017/10/09/linux下修改防火墙配置重启命令/","text":"在/etc/sysconfig/iptables里添加 # vi /etc/sysconfig/iptables 添加一条配置规则，如要想开放8080的端口，如下所示： -A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 8080 –j ACCEPT 重启iptables # /etc/init.d/iptables restart 看下状态 # /etc/init.d/iptables status 4.关闭防火墙 （1） 重启后永久性生效： 开启：chkconfig iptables on 关闭：chkconfig iptables off （2） 即时生效，重启后失效（即重启后防火墙自动开启）： 开启：service iptables start 关闭：service iptables stop","tags":[{"name":"linux","slug":"linux","permalink":"http://blog.xmqbeast.com/tags/linux/"}]},{"title":"使用mongoDB创建数据库","date":"2017-10-09T09:43:53.000Z","path":"2017/10/09/使用mongoDB创建数据库/","text":"如何在 MongoDB 中创建数据库 use 命令 MongoDB使用 use DATABASE_NAME 命令来创建数据库。如果指定的数据库DATABASE_NAME不存在，则该命令将创建一个新的数据库，否则返回现有的数据库。 语法 use DATABASE 语句的基本语法如下 - use DATABASE_NAME 示例 如果要创建一个名称为的数据库，那么使用 use DATABASE 语句将如下所示： &gt; use newdb switched to db newdb 如果要检查数据库列表，请使用命令：show dbs。 &gt;show dbs local 0.000025GB test 0.00002GB 创建的数据库(newdb)不在列表中。要显示数据库，需要至少插入一个文档，空的数据库是不显示出来的。 &gt;db.items.insert({&quot;name&quot;:&quot;yiibai tutorials&quot;}) &gt;show dbs local 0.00005GB test 0.00002GB newdb 0.00002GB 在 MongoDB 中默认数据库是：test。 如果您还没有创建过任何数据库，则集合/文档将存储在test数据库中。","tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://blog.xmqbeast.com/tags/mongodb/"}]},{"title":"maven deploy到nexus报401，Unauthorized","date":"2017-10-09T09:18:55.000Z","path":"2017/10/09/maven-deploy到nexus报401，Unauthorized/","text":"提交到nexus时候报错： [ERROR] Failed to execute goal org.apache.maven.plugins:maven-deploy-plugin:2.7:deploy (default-deploy) on project : Failed to deploy artifacts: Could not transfer artifact :jar:1.0 from/to releases (http://10.1.81.199:8081/nexus/content/repositories/releases/): Failed to transfer file: http://10.1.81.199:8081/nexus/content/repositories/releases/com/cs2c/security-management-client /1.0/-1.0.jar. Return code is: 401, ReasonPhrase:Unauthorized. 原来是没有配置认证。 maven目录conf的setting.xml里， &lt;servers&gt; &lt;server&gt; &lt;id&gt;releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; 用户名和密码都是nexus的。再次deploy即可。 注意这里的id要和pom.xml里远程deploy的地址对应一致，我的pom.xml里配置： &lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;releases&lt;/id&gt; &lt;name&gt;Nexus Release Repository&lt;/name&gt; &lt;url&gt;http://10.1.81.199:8081/nexus/content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;name&gt;Nexus Snapshot Repository&lt;/name&gt; &lt;url&gt;http://10.1.81.199:8081/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt; 如果这里不配置，会报错： 报错：Failed to execute goal org.apache.maven.plugins:maven-deploy-plugin:2.5:deploy (default-deploy) on project git-demo: Deployment failed: repository element was not specified in the POM inside distributionManagement element or in -DaltDeploymentRepository=id::layout::url parameter","tags":[{"name":"maven","slug":"maven","permalink":"http://blog.xmqbeast.com/tags/maven/"},{"name":"nexus","slug":"nexus","permalink":"http://blog.xmqbeast.com/tags/nexus/"}]},{"title":"svn Can't open file '/svn/stdrepo/db/txn-current-lock","date":"2017-10-08T14:27:08.000Z","path":"2017/10/08/svn-Can-t-open-file-svn-stdrepo-db-txn-current-lock/","text":"solution: sudo chmod -R g+rws /svn/stdrepo","tags":[{"name":"svn","slug":"svn","permalink":"http://blog.xmqbeast.com/tags/svn/"}]},{"title":"linux下安装配置nexus","date":"2017-10-07T18:43:55.000Z","path":"2017/10/08/linux下安装配置nexus/","text":"为什么要搭建maven私服？ 在开发过程中，有时候会使用到公司内部的一些开发包，显然把这些包放在外部是不合适的。另外，由于项目一直在开发中，这些内部的依赖可能也在不断的更新。可以通过搭建公司内部的Maven服务器，将第三方和内部的依赖统一管理，同时也可以节省网络带宽，当然前提是项目所需要的构件在私服中已经存在。 Nexus下载及安装配置 我们可以在nexus的官网上找到它的相关介绍，下载地址是：http://www.sonatype.org/nexus/go 下载 # wget https://sonatype-download.global.ssl.fastly.net/nexus/oss/nexus-2.11.2-03-bundle.tar.gz 解压 # cd /usr/local # mkdir nexus # tar -zxvf /opt/java/nexus-2.14.5-02-bundle.tar.gz -C /usr/local/nexus # cd nexus # ls (显示如下两个文件夹) nexus-2.11.2-03 sonatype-work 修改配置文件 # cd nexus-2.11.2-03/conf # vi nexus.properties #Jetty section application-port=8081 ##修改Jetty端口号 # nexus section nexus-work=${bundleBasedir}/../sonatype-work/nexus 保存以上修改 配置用户 # vi /usr/local/nexus/nexus-2.11.2-03/bin/nexus #RUN_AS_USER= RUN_AS_USER=root 保存以上修改 若有设置防火墙，需前往修改防火墙配置并重启防火墙，此处略过…… 启动nexus # /usr/local/nexus/nexus-2.11.2-03/bin/nexus start **************************************** WARNING - NOT RECOMMENDED TO RUN AS ROOT **************************************** Starting Nexus OSS... Started Nexus OSS. 在浏览器打开:http://ip:8081/nexus,登录：用户名admin 默认密码：admin123在项目中修改maven仓库地址这样就配置完成了。在构建maven项目时，如果在私服中存在需要的构件，则会直接从私服中下载；如果私服中没有所需构件，则会先从网络上下载到私服，之后才会下载到本地。","tags":[{"name":"linux","slug":"linux","permalink":"http://blog.xmqbeast.com/tags/linux/"}]},{"title":"hexo常用命令","date":"2017-10-07T18:01:54.000Z","path":"2017/10/08/hexo常用命令/","text":"常见命令 hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 缩写： hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 组合命令： hexo s -g #生成并本地预览 hexo d -g #生成并上传","tags":[{"name":"linux","slug":"linux","permalink":"http://blog.xmqbeast.com/tags/linux/"}]},{"title":"linux下安装pm2","date":"2017-10-07T06:15:55.000Z","path":"2017/10/07/linux下安装pm2/","text":"如果可以联网 直接执行：npm install -g pm2 登录部署服务器 执行 npm config get prefix 看一下这台服务器的npm默认安装目录， 例如目录为 ： /opt/java/node-v6.11.4-linux-x64 到这一步，你已经可以使用 /opt/java/node-v6.11.4-linux-x64/lib/node_modules/pm2/bin/pm2 执行pm2的命令了， 下面就是把这个命令加到系统环境中 ln -s /opt/java/node-v6.11.4-linux-x64/lib/node_modules/pm2/bin/pm2 /usr/local/bin/pm2 下面就是把这个命令加到系统环境中 这样，就可以直接使用pm2命令来各种操作了","tags":[{"name":"linux","slug":"linux","permalink":"http://blog.xmqbeast.com/tags/linux/"}]},{"title":"linux下安装node环境","date":"2017-10-07T05:46:43.000Z","path":"2017/10/07/linux下安装node环境/","text":"首先去官网下载代码，这里一定要注意安装分两种，一种是Source Code源码，一种是编译后的文件。 （一） 编译好的文件 简单说就是解压后，在bin文件夹中已经存在node以及npm，如果你进入到对应文件的中执行命令行一点问题都没有，不过不是全局的，所以将这个设置为全局就好了。 cd node-v0.10.28-linux-x64/bin ls ./node -v 然后设置全局： ln -s /opt/java/node-v6.11.4-linux-x64/bin/node /usr/local/bin/node ln -s /opt/java/node-v6.11.4-linux-x64/bin/npm /usr/local/bin/npm 这里/home/kun/mysofltware/这个路径是你自己放的，你将node文件解压到哪里就是哪里。 （二）通过源码编译 这种方式你下载的文件是Source code， # tar xvf node-v0.10.28.tar.gz # cd node-v0.10.28 # ./configure # make # make install # cp /usr/local/bin/node /usr/sbin/ 查看当前安装的Node的版本 # node -v v6.11.4 （三）apt-get 还有一种就是shell提示的apt-get方式 sudo apt-get install nodejs sudo apt-get install npm 这么装完你会发现,node命令好使，nodejs命令可以用","tags":[{"name":"linux","slug":"linux","permalink":"http://blog.xmqbeast.com/tags/linux/"}]},{"title":"linux下解压tar.xz文件","date":"2017-10-07T05:39:09.000Z","path":"2017/10/07/linux下解压tar-xz文件/","text":"这个压缩包也是打包后再压缩，外面是xz压缩方式，里层是tar打包方式。 使用如下命令： 1234$xz -d ***.tar.xz$tar -xvf ***.tar 补充：目前也可以直接使用 tar xvJf ***.tar.xz来解压","tags":[{"name":"linux","slug":"linux","permalink":"http://blog.xmqbeast.com/tags/linux/"}]},{"title":"DOClever介绍","date":"2017-10-07T05:30:13.000Z","path":"2017/10/07/DOClever介绍/","text":"什么是DOClever？DOClever是一个商业化开源产品，完全免费。无论你是前端工程师，还是后端工程师，接口永远都是两者交互的桥梁，所以DOClever专为中小型团队量身打造，旨在解决接口的管理，测试与数据生成，实现真正的一体化解决方案。DOClever有哪些功能1.可以对接口信息进行编辑管理，支持get,post,put,delete,patch五种方法，支持https和https协议，并且支持query，body，json，raw，rest，formdata的参数可视化编辑。同时对json可以进行无限层次可视化编辑。并且，状态码，代码注入，markdown文档等附加功能应有尽有。2.接口调试运行，一个都不能少，可以对参数进行加密，从md5到aes一应俱全，返回参数与模型实时分析对比，给出不一致的地方，找出接口可能出现的问题。如果你不想手写文档，那么试试接口的数据生成功能，可以对接口运行的数据一键生成文档信息。3.mock的无缝整合，DOClever自己就是一个mock服务器，当你把接口的开发状态设置成已完成，本地mock便会自动请求真实接口数据，否则返回事先定义好的mock数据。4.支持postman，rap，swagger的导入，方便你做无缝迁移，同时也支持html文件的导出，方便你离线浏览！5.项目版本和接口快照功能并行，你可以为一个项目定义1.0，1.1，1.2版本，并且可以自由的在不同版本间切换回滚，再也不怕接口信息的遗失，同时接口也有快照功能，当你接口开发到一半或者接口需求变更的时候，可以随时查看之前编辑的接口信息。6.自动化测试功能，目前市面上类似平台的接口自动化测试大部分都是伪自动化，对于一个复杂的场景，比如获取验证码，登陆，获取订单列表，获取某个特定订单详情这样一个上下文关联的一系列操作无能为力。而DOClever独创的自动化测试功能，只需要你编写极少量的javascript代码便可以在网页里完成这样一系列操作，同时，DOClever还提供了后台定时批量执行测试用例并把结果发送到团队成员邮箱的功能，你可以及时获取接口的运行状态。7.团队协作功能，很多类似的平台这样的功能是收费的，但是DOClever觉得好东西需要共享出来，你可以新建一个团队，并且把团队内的成员都拉进来，给他们分组，给他们分配相关的项目以及权限，发布团队公告等等。8.DOClever开源免费，支持内网部署，很多公司考虑到数据的安全性，不愿意把接口放到公网上，没有关系，DOClever给出一个方便快捷的解决方案，你可以把平台放到自己的内网上，完全不需要连接外网，同时功能一样也不少，即便是对于产品的升级，DOClever也提供了很便捷的升级方案！产品文档http://doclever.cnDOClever开源本次开源的是DOClever的内网版本，可以直接部署到内网中，和线上版本在功能上是完全一样的，区别在于：1.线上的系统用了前端和后端两套工程，并且用nginx做了负载均衡，redis做缓存，而内网版本合并为一个工程，直接用node做静态服务器，取消了缓存，这样对于很多中小型团队来说很轻便而且也够用了。2.线上系统在安全性方面做了不少加固处理，而内网版本默认内网是安全的，也为了提高node作为服务器的效率，取消了很多加固处理，如果用户有需要可以自行添加。如何部署1.首先本地要安装node环境，推荐6.10.0版本(下载页面)2.安装mongodb(下载页面)，可使用robomongo来作为mongodb的客户端工具(下载页面)，启动mongodb后（如何启动），用robomongo来连接，新建一个database作为DOClever的数据库（名称随意）3.将DOClever的源码down到本地，在命令行下运行node DOClever的根目录/Server/bin/www（如果是windows环境下，请修改目录分隔符)，第一次启动，会出现命令行提示符，按照提示符输入即可完成相关的配置，等到DOClever启动成功后， 在浏览器里输入localhost:DOClever启动的端口号,出现首页表示部署成功。 github地址https://github.com/sx1989827/DOClever","tags":[{"name":"opensource","slug":"opensource","permalink":"http://blog.xmqbeast.com/tags/opensource/"}]},{"title":"linux下安装jsvnadmin","date":"2017-10-06T16:17:40.000Z","path":"2017/10/07/linux下安装jsvnadmin/","text":"jsvnadmin-Subversion Web Admin Introduction Web Client for Subversion Configuration: Repositories management Users management Groups management Access rights management Supports svn or http(Apache) protocol Supports password encryption Supports multiple databases Supports multiple operating system Supports browse repositories online(since 3.0.2) Supports multiple languages (since 3.0.2) 什么是Svn Admin 【svnadmin介绍】Svn Admin是一个Java开发的管理Svn服务器的项目用户的web应用。安装好Svn服务器端好，把Svn Admin部署好，就可以通过web浏览器管理Svn的项目，管理项目的用户，管理项目的权限。使得管理配置Svn简便，再也不需要每次都到服务器手工修改配置文件。 【有什么优点】 *多数据库：Svn项目配置数据保存在数据库，支持所有数据库（默认MySQL/Oracle/SQL Server）。 *多操作系统：支持Window,Linux等操作系统。 *权限控制：管理员可以随意分配权限、项目管理员可以管理项目成员、成员只能查看和修改自己的密码。 *支持多项目、多用户、多用户组Group（默认带有“项目管理组”、“项目开发组”、“项目测试组”）。 *安全：密码加密保存。 *多协议：支持svn协议和http协议(从2.0开始支持Apache服务器单库方式，从3.0开始支持Apache多库方式) *仓库浏览(从3.0.2开始) *多语言(从3.0.2开始) 【是否适合你】 Svnadmin在Java 1.6、Tomcat 6、Subversion 1.6、MySQL 5.1、Apache 2.2、Windows 7上开发测试通过，同时支持其他操作系统和数据库。 *支持svn协议 Svn的配置信息都在仓库目录的conf下的authz,passwd,svnserve.conf三个文件中，配置用户和权限都是通过修改passwd和authz，立刻就生效。Svn Admin的本质是对这3个文件进行管理，所有成员、权限的数据都保存在数据库中，一旦在Svn Admin的页面上修改，就会把配置信息输出到conf下的那3个配置文件中。 *支持http协议 Apache+SVN配置成功后可以有两种方式： 1.多库方式：SVNParentPath 指定一个父目录，所有仓库在这个父目录下，使用一个密码文件和一个权限配置文件。优点是增加删除仓库不需要改apache的httpd.conf，不需要重启Apache。缺点是项目多会很混乱 2单库方式：SVNPath 每个仓库单独配置各自的密码和权限文件。优点是各自分开，互相不影响，维护方便。缺点是增加或删除仓库需要修改apache的httpd.conf后重启。 下载地址：https://code.google.com/p/jsvnadmin/ https://jsvnadmin.googlecode.com/files/svnadmin-3.0.5.zip","tags":[{"name":"linux","slug":"linux","permalink":"http://blog.xmqbeast.com/tags/linux/"}]},{"title":"linux下安装Subversion+Apache","date":"2017-10-06T15:30:27.000Z","path":"2017/10/06/linux下安装Subversion-Apache/","text":"root用户操作 建议安装前更新操作系统 12# yum update 更新完成后重启 12#reboot 安装apache 1234# yum install httpd httpd-devel# service httpd start# chkconfig httpd on //配置httpd开机启动 12#vi /etc/httpd/conf/httpd.conf 找到ServerName并修改成【ServerName localhost:80】 防火墙中打开80端口： 1234# vi /etc/sysconfig/iptables-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT# service iptables restart http://192.168.1.119/ 安装SVN服务 12# yum install mod_dav_svn subversion 必须安装mod_dav_svn模块 安装完svn后要重启apache 12# service httpd restart 查看测试是否安装svn模块 12345# ls /etc/httpd/modules/ | grep svn mod_authz_svn.so mod_dav_svn.so# svn --version 在根目录下创建svn库主目录（多库模式，一份配置文件管理多个库） 1234# mkdir /svn/# cd/etc/httpd/conf.d# ls 此时可以看到一个subversion.conf配置文件（是在安装mod_dav_svn模块时生成的） 12# vi subversion.conf 添加以下内容 12345678910111213#Include /svn/httpd.conf&lt;Location /svn/&gt;DAV svnSVNListParentPath onSVNParentPath /svnAuthType BasicAuthName \"Subversion repositories\"AuthUserFile /svn/passwd.httpAuthzSVNAccessFile /svn/authzRequire valid-user&lt;/Location&gt;RedirectMatch ^(/svn)$ $1/ 创建/svn/passwd.http和/svn/authz 123# touch /svn/passwd.http# touch /svn/authz 重启apache 12# service httpd restart 重启成功说明我们添加的配置是没有问题的","tags":[{"name":"linux","slug":"linux","permalink":"http://blog.xmqbeast.com/tags/linux/"}]},{"title":"hexo添加tags","date":"2017-10-06T09:00:08.000Z","path":"2017/10/06/hexo添加tags/","text":"步骤一新建一个页面，命名为 tags 。命令如下： 12$ hexo new page \"tags\" 步骤二这时会在在sources/tags里面有个index.md的文件，打开这个文件编辑将页面的类型设置为 tags ，主题将自动为这个页面显示标签云。页面内容如下： 123456title: Tagclouddate: 2014-12-22 12:39:04type: \"tags\"comments: false--- 注意：如果有启用多说或者Disqus评论，默认页面也会带有评论。需要关闭的话，需要添加字段comments并将该值设置为false（如上） 步骤三在菜单中添加链接。编辑 主题(这里以next为例)配置文件 ，添加 tags 到 menu 中，如下: 1234567menu: home: / archives: /archives tags: /tags //确保标签页已打开 #schedule: /schedule #commonweal: /404.html 注意：所有冒号后面都有个空格 hexo一篇文章添加多个tags用法为：tags:[linux,c,c++]","tags":[{"name":"hexo","slug":"hexo","permalink":"http://blog.xmqbeast.com/tags/hexo/"}]},{"title":"linux下安装MongoDB","date":"2017-10-05T17:47:34.000Z","path":"2017/10/06/linux下安装MongoDB/","text":"MongoDB 提供了 linux 各发行版本 64 位的安装包，你可以在官网下载安装包。 下载地址：https://www.mongodb.com/download-center#community 下载完安装包，并解压 tgz（以下演示的是 64 位 Linux上的安装。 123456curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.0.6.tgz # 下载tar -zxvf mongodb-linux-x86_64-3.0.6.tgz # 解压mv mongodb-linux-x86_64-3.0.6/ /usr/local/mongodb # 将解压包拷贝到指定目录 MongoDB 的可执行文件位于 bin 目录下，所以可以将其添加到 PATH 路径中： 12export PATH=&lt;mongodb-install-directory&gt;/bin:$PATH 为你 MongoDB 的安装路径。如本文的 /usr/local/mongodb 创建数据库目录 MongoDB的数据存储在data目录的db目录下，但是这个目录在安装过程不会自动创建，所以你需要手动创建data目录，并在data目录中创建db目录。以下实例中我们将data目录创建于根目录下(/)。 注意：/data/db 是 MongoDB 默认的启动的数据库路径(–dbpath)。 12mkdir -p /data/db 命令行中运行 MongoDB 服务 你可以再命令行中执行mongo安装目录中的bin目录执行mongod命令来启动mongdb服务。 注意：如果你的数据库目录不是/data/db，可以通过 –dbpath 来指定。 12./mongod -dbpath /data/db -logpath /usr/local/mongodb/log/mongodb.log -logappend -fork -port 27017 MongoDB后台管理 Shell 如果你需要进入MongoDB后台管理，你需要先打开mongodb装目录的下的bin目录，然后执行mongo命令文件。 MongoDB Shell是MongoDB自带的交互式Javascript shell,用来对MongoDB进行操作和管理的交互式环境。 当你进入mongoDB后台后，它默认会链接到 test 文档（数据库）： 1234567$ cd /usr/local/mongodb/bin$ ./mongoMongoDB shell version: 3.0.6connecting to: testWelcome to the MongoDB shell.…… 由于它是一个JavaScript shell，你可以运行一些简单的算术运算: 12345&gt; 2+24&gt; 3+69 现在让我们插入一些简单的数据，并对插入的数据进行检索： 123456&gt; db.runoob.insert(&#123;x:10&#125;)WriteResult(&#123; \"nInserted\" : 1 &#125;)&gt; db.runoob.find()&#123; \"_id\" : ObjectId(\"5604ff74a274a611b0c990aa\"), \"x\" : 10 &#125;&gt; 第一个命令将数字 10 插入到 runoob 集合的 x 字段中。 MongoDb web 用户界面 MongoDB 提供了简单的 HTTP 用户界面。 如果你想启用该功能，需要在启动的时候指定参数 –rest 。 12$ ./mongod --dbpath=/data/db --rest MongoDB 的 Web 界面访问端口比服务的端口多1000。 如果你的MongoDB运行端口使用默认的27017，你可以在端口号为28017访问web用户界面，即地址为：http://localhost:28017。","tags":[{"name":"linux","slug":"linux","permalink":"http://blog.xmqbeast.com/tags/linux/"}]},{"title":"使用hexo，如果更换了电脑如何更新博客","date":"2017-10-05T01:46:26.000Z","path":"2017/10/05/使用hexo，如果更换了电脑如何更新博客/","text":"一、关于搭建的流程 1.创建仓库:xtzeng.github.io; 2.创建两个分支：master和hexo; 3.设置hexo为默认分支（因为我们只需要手动管理这个分支上的hexo网站文件）; 4.git clone https://github.com/xtzeng/xtzeng.github.io.git拷贝仓库（hexo分支-默认）; 5.在本地xtzeng.github.io文件夹下通过git bash依次执行npm install hexo、hexo init、npm install和npm install hexo-deployer-git(此时当前分支应显示为hexo); 6.修改_config.yml中的deploy参数，分支应为master; 7.依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件； 8.执行hexo g -d 生成网站并部署到github上； 这样一来，在github上的xtzeng.github.io仓库就有两个分支，一个hexo分支用来存放网站的文件，一个master分支用来存放生成的静态文件。 二、关于日常的流程改动 在本地对博客进行修改（添加新博客、修改样式等等）后，通过下面的流程进行管理。 1.依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到github(此时当前分支应为hexo); 2.然后才执行hexo g -d 发布到master分支上。 虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没有问题的（例如突然死机要重装了，悲催…的情况，调转顺序就有问题了）。 三、本地资料丢失后的流程 当重装电脑之后，或者想在其他电脑上修改博客，可以使用以下步骤： 1.使用git clone https://github.com/xtzeng/xtzeng.github.io.git 拷贝仓库（默认分支为hexo）; 2.在本地新拷贝的xtzeng.github.io文件夹下通过git bash依次执行以下指令：npm install hexo、npm install、npm install hexo-deployer-git(记得，不需要hexo init 这条指令)","tags":[{"name":"hexo","slug":"hexo","permalink":"http://blog.xmqbeast.com/tags/hexo/"}]},{"title":"spring cloud（一）服务注册与发现--eureka-server","date":"2017-08-10T13:19:57.000Z","path":"2017/08/10/spring cloud（一）服务注册与发现--eureka-server/","text":"1、在默认设置下，Eureka服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为。 禁止方式如下： eureka.client.register-with-eureka=falseeureka.client.fetch-registry=false 2.微服务架构 微服务架构是将一个完整的应用从数据存储垂直拆分成多个不同的服务，每个服务都能独立部署、独立维护、独立扩展，服务与服务之间通过诸如RESTful API的方式相互调用 3.服务注册与发现 如何使用Spring Cloud搭建服务注册与发现模块 我们会用到Spring Cloud Netflix,该项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。主要提供的模块包括：服务发现(Eureka),断路器(Hystrix),智能路由(Zuul),客户端负载均衡(Ribbon)等。 4.创建“服务注册中心” 创建一个基本的Spring Boot工程，并在pom.xml中引入如下内容： 12345678910111213141516171819202122232425262728 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.3.7.RELEASE&lt;/version&gt; &lt;relativePath&gt;&lt;/relativePath&gt; &lt;/parent&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Brixton.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;， 5.通过@EnableEurekaServer注解启动一个服务注册中心提供给其他应用进行对话。这一步非常简单，只需要在一个普通的Spring Boot项目中添加这个注解就能开启此功能，如下： 12345678@EnableEurekaServer@SpringBootApplicationpublic class MiaoMiaoApplicationEurekaServer &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(MiaoMiaoApplicationEurekaServer.class).web(true).run(args); &#125;&#125; 6.在默认的设置下，该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为，只需要在application.properties中增加如下配置： 12345server.port=1111eureka.client.register-with-eureka=falseeureka.client.fetch-registry=falseeureka.client.serviceUrl.defaultZone=http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 7.为了和后续要进行注册的服务区别，这里将服务注册中心的端口通过server.port属性设置为1111. 启动工程后，访问：http://localhost:1111/ 8.创建“服务提供方” 下面我们创建提供服务的客户端，并向服务注册中心注册自己。 首先，我们再创建一个Spring Boot 应用，并在pom.xml中加入以下配置： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; 其次，我们实行/hello请求处理接口，通过DiscoveryClient对象，在日志中打印出服务实例的相关内容。 1234567891011121314151617181920212223242526 @RestController public class HelloWorldController &#123; private final Logger logger = Logger.getLogger(getClass()); @Autowired private DiscoveryClient discoveryClient; @RequestMapping(value = \"/hello\",method = RequestMethod.GET) public String hello() throws Exception&#123; ServiceInstance instance = discoveryClient.getLocalServiceInstance(); //测试超时触发断路器 int sleepTime = new Random().nextInt(3000); logger.info(\"sleepTime:---------&gt;&gt;&gt;&gt;\"+sleepTime); Thread.sleep(sleepTime); logger.info(\"/hello,host:---&gt;&gt;&gt;\"+instance.getHost()+\",service_id:---&gt;&gt;&gt;\"+instance.getServiceId()); return \"Hello World\"; &#125;&#125; 最后在主类中通过加上@EnableDicoveryClient注解，该注解能激活Eureka中的DicoveryClient实现，才能实现Controller中对服务信息的输出。 12345678910 @EnableDiscoveryClient @SpringBootApplication public class MiaoMiaoServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MiaoMiaoServiceApplication.class,args); &#125;&#125; 在完成了服务内容的实现之后，再继续对application.properties做一些配置工作，具体如下： 12345spring.application.name=miaomiao-spring-cloud-eureka-serviceserver.port=8082eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/ 通过spring.application.name属性，我们可以指定微服务的名称后续在调用的时候只需要使用该名称就可以进行服务的访问。 eureka.client.serviceUrl.defaultZone属性对应服务注册中心的配置内容，指定服务注册中心的位置。 为了在本机上测试区分服务提供方跟服务注册中心，使用server.port属性设置不同的端口。 启动该工程后，再次访问：http://localhost:1111/ 可以看到，我们定义的服务被注册了。","tags":[]},{"title":"如何高效的完成不喜欢的工作/学习任务","date":"2017-06-01T09:24:45.000Z","path":"2017/06/01/如何高效的完成不喜欢的工作-学习任务/","text":"进化心理学认为：人天生就是理性的动物，据说这种理性的能力把我们跟其他动物分开。而古希腊的柏拉图和亚里士多德也发现了这一现象，并提出了“意志薄弱”这一哲学问题，即：我们明知道学习对我们有利，但总不喜欢做，或是即使勉强学习，也是拖拖拉拉，效率低下。而这种拖延的低效学习，往往又会对人产生负罪感，从而恶性循环。 但事实上，掌握合适自己的学习方法，将它变成一种生活中的习惯，保持高效率的学习，并不是一件不可能完成的事。以下推荐的几种方法，或许能让你一点点改变拖延的毛病 1.帕累托定律与时间管理的“三只青蛙” 1897年，意大利经济学者帕累托偶然注意到19世纪英国人的财富和收益模式。他从大量具体的事实中发现：社会上20%的人占有80%的社会财富。这个现象在工作和学习中也是通用的，把二分法则运用得熟练，可以将那些影响最小，价值最低的工作和最重要，价值最高的任务区分开来。 而在时间管理中，也有“三只青蛙”的说法。“三只青蛙”，即一天中最重要的三件任务。我们可以将这二者结合起来，确定属于自己的一天中，最重要和紧急的三件事（“三只青蛙”），运用早晨块状的时间，把他们一个个“吃掉”。而最优先“吃掉”的青蛙，自然是最丑最大（最重要）的那只。 在《超效率理论》这本书里，同样提到了“让你的时间头重脚轻”的观点：一个高效的工作日程，往往是把一天中最难做，最费头脑的事情做完。如果相反，人们总是还没有做到最重要的工作，就已经疲惫不堪了。头重脚轻的工作安排，容易产生许多好处。当你在早上完成了最难啃的任务之后，就算累了，也有信心来处理其他杂事。 2.番茄工作法与任务清单 无论是学习还是工作，最大的阻碍就是拖延。曾国藩曾经说过，一勤天下无难事，这句话虽然有鸡汤的成分，但也从侧面说明了人们普遍懒惰的劣性。而在限定的时间内，规定自己必须完成一些任务，既是保障高效工作的前提，也是面对拖延这个小恶魔“残酷”的考验 番茄工作法是一种简易的时间管理方法。具体的内容是将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后进行短暂的5分钟休息。每4个番茄时段多休息一会儿。 番茄工作法的优点在于，一则时间短，半个小时的工作总是比连续几个小时更容易让人在心理上接受。另一个则在于营造的紧迫感和压力感，它会促使你不知不觉的加快工作的速度和效率。 而想要保障高效率的工作，一份目标明确的任务清单也是必不可少，不明确的任务清单是滋生拖延症的温床。如果我在自己的任务清单里第一条写着：完成毕业论文。那么最有可能出现的场景是：我深情的望着这六个大字发呆，然后拿起手机，百度了半个小时，之后选择放弃，去玩斗地主去了。 所以，正确的任务清单应该是清晰而准确的。写毕业论文这几个字，我可以把它理解为：选题，找研究材料，作注释，写论点，甚至可以更加细化。再比如说打扫房间卫生，这件事的时间限定是模糊的，我可以在20分钟内将它搞定，也可以拖上一个礼拜。如果没有番茄钟的监督，许多事可能就会永远耽搁下去。当然，番茄钟也只是一种方法，你需要的，只是一个能够监督你有效利用时间的工具而已。 3.结构拖延法与动力催化 约翰·佩里在他的《拖拉一点也无妨》这本书里，介绍了一种用逆向思维战胜拖延症的方法–结构化拖延法。结构化拖延法正是利用了拖延者的这种心态，为某人必须完成的那些任务梳理出一个结构。譬如说我明天打算完成五件事： 完成一篇文案稿件 背诵100个单词 写一篇知乎回答 看完一部电影并写下观后感 跑完5公里 在这五件事里，前三件排列在先的任务，对我来说是当天最重要。但是当我早上醒来，准备写文案稿件的时候，我发现自己毫无头绪，那么为了避免一事无成的焦虑感，我就会选择先完成第四项和第五项，从心理上告诉自己：我今天可不是什么也没有做。 这样虽然我的稿子今天还是没有写，但至少比玩了一天的手机强。 这种结构拖延法与上述的帕累托定律看似矛盾，但是在不同的学习任务中仍然可供作不同的选择。不论是哪种方法，只要从这些很小的习惯中坚持，变成一个良性循环，就能获得源源不断的力量。 此外，《心理暗示力》中提到了一条重复定律：任何的行为和思维，只要你不但的重复就会得到不断的加强。在你的潜意识当中，只要你能够不断地重复一些人、事、物，它们都会在潜意识里变成事实。 把你的目标列成一个表，放在电脑桌面上。把能刺激你的事写成便签，放在工作中显眼的位置，把你的公开承诺告诉你身边的人，因担心自己做不到产生的压力会让你保持动力。类似这些小方法，都可以成为你前进的动力催化。 4.日程校对与避免刺激 如果你将你想要做的事写在任务清单上，却没有完成，就会产生拖延。如果你将任务清单上的事完成了，还想要加上一些的时候，就是在破坏信任。任务清单必须要保障它的权威性。 有时候过度勤奋并不是一件好事，你把预计三天的任务清单在一天内做完，看似高效，但实际上却破坏了这份清单的权威。下一次，你可能就会不太重视它了，因为在你的潜意识里，它是可以变更的，这并不是一个好的信号，它或许会打破你的自律。 日程校对是你对你的任务清单有着明确的认知，当你没做完的时候，坚持把他们做完。如果完成了，你就停下。 在这个碎片化信息充斥着我们生活的时代，有太多的事容易让我们分心了。微信上闪烁不停的群消息是刺激，收件箱里的广告也是刺激。所以，当我们要开始工作的时候，请关闭掉这一些能够打扰你的信息刺激。否则，你是无法做到专注的。 5.保持活力与监督反馈 高效率的工作是一件很费精力的事，所以这就更需要我们保持自身的活力。在你疲惫的时候，两个小时完成的任务，可能在清醒的时候，40分钟就能够做完。 想要维持高效率的工作，除了日常的运动以外，为体能进食也尤为重要，血糖高低的水平对体能有着极大的影响。你吃的每种食物都有着对应的血糖值，血糖值高，对你短跑和短暂的运动是有利的，但是在一天的学习中，却未必是好事。所以，多吃低血糖值的全谷物食物吧，它们释放的热量的速度较慢，可以让你不会经历含糖食物快速消耗的冲击。如果条件允许的话，少食多餐也对你的精力保持很有帮助。 再来谈谈监督和反馈。如果你决定每天打卡一百个单词，坚持一百天。你独自完成成败的概率肯定远远大于一群人监督你完成失败的概率。因为什么？因为你怕丢脸呀。如果你告诉了身边的好友，甚至发了朋友圈，下次坚持不住想要放弃的时候，想想那些给你点赞的人，那些等着你失败嘲笑你的人，是不是又重新有了勇气？ 很多时候你优柔寡断下不定决心去学习工作，其实只是缺少一个破釜沉舟的勇气而已。如果别人的嘲讽对你来说都没有用，那就用金钱吧。给自己设定一个有些难度，但是又能够完成的目标，给朋友支付一笔你能够承受的“巨款”，然后让他来监督你。在预计的时间内，你做到了，钱就还给你，做不到，钱就归他。相信这种简单粗暴的方法，能够让很多人振作起来。 既然有了惩罚，那么必然就要有奖励。比如：每天坚持练习半小时吉他，一个月后就奖励自己一双跑鞋。每天看完一小时的书，一个月就奖励自己一部kindle，这些增加目标收益，及时反馈，给予自我奖励的方式，都是不错的方法。 6.养成早起的习惯和独特的仪式感 早起并不是因为鸡汤书上说的，早起就能够成功，而是因为早起能够训练意志力和自控力，形成习惯化的规律生活。我曾经试过一段时间每天睡到中午自然醒，结果就是，精力变得越来越差，十二点半起床洗漱吃完外卖后，打开电脑工作，到下午三四点又忽忽犯困了，这时候如果不睡，做事效率会变得越来越低，如果睡去，到了晚上，没有一两点又是睡不着的。一整天下来，诧异的法信，真正有效率的工作时间竟然只有两三个小时。 作为一个熬夜多年的夜猫子，我也尝试过多种方法督促自己早睡，但是不论是听纯音乐，还是深呼吸数绵羊，统统都没用。无数个辗转反侧的夜里，我总是忍不住睁开通红的双眼，缓缓摁亮手机。 后来我发现真正有用的，只有早起，不曾在清晨的阳光里睁开疲惫双眼的夜猫，不足以人生。只有当你忍受了多次睡眠不足还要坚持起床的苦痛，你才能真正明白早睡的幸福。 早起需要准备什么？ 一个准时响起的闹钟以及一个属于自己的仪式习惯就够了。闹钟这点不必多说，如果你打算6点起床，6点半开始一天的工作，我的建议是5：57分的闹钟，一首歌的时间让自己从混沌走向清醒。 而需要仪式感，是因为我们的主动性和自律性比我们想象的更加稀缺。阿里纳斯在罚球之前，喜欢在接球之后把球在腰部绕上三个圈。网球运动员发球时，有的喜欢摸一下自己的鼻子。这些有意无意的信号，都是在心里给予自己暗示。 需要什么样的仪式感呢？其实很简单，按照自己喜欢的来吧，早上听完一首歌曲再去刷牙洗脸，锻炼完10分钟keep以后喝一杯温水，怎么样都好，你只是需要给予自己一个满血复活的一天现在开始了的信号。 其实最重要的还是自己能明白高效率工作和学习给自己带来的乐趣。它不仅仅在于当你完成了任务清单能够放心的领到奖金或是不会挂科，更在于有智慧和效率的学习与工作，能够提升自己的生活质量。","tags":[]},{"title":"linux命令-系统管理","date":"2017-04-28T08:47:59.000Z","path":"2017/04/28/linux命令-系统管理/","text":"1.查看当前日历：cal cal 用于查看当前日历，-y显示整年日历： 2.显示或设置时间：date 3.查看进程信息：ps 小知识（以ps为例）： 查看命令路径，which ps (显示-/bin/ps) 命令帮助：ps –help 命令完全手册：man ps 说明：ps全称是:process status(进程)，他是提供进程信息的 ps命令用于报告当前系统的进程状态，可以搭配kill命令使用随时中断、删除没用的进程。 进程是一个具有独立功能的程序，它是操作系统动态执行的基本单元。 ps命令可以查看进程的详细状况，常用选项如下： 选项 含义 -a 显示终端上的所有进程，包括其他用户的进程 -u 显示进程的详细状态 -x 显示没有控制终端的进程 -W 显示加宽，以便显示更多的信息 -r 只显示正在运行的进程 方法一：使用ps命令查看程序端口占用情况ps -aus | grep tomcat 使用命令查看所有进程和端口使用情况：netstat -apn 进一步使用命令：ps -aux | grep java 或者直接：ps -aux |grep pid方法二：直接使用netstat -anp | grep portno即:netstat -apn | grep 8080 4.动态显示进程：top top命令用来动态显示运行中的进程。top命令能够在运行后，在指定的时间间隔更新显示信息。可以在top命令时加上-d来指定显示信息更新的时间间隔。 在top命令执行后，可以按下按键得到对显示的结果进行排序： 按键 含义 M 根据内存使用量来排序 P 根据CPU占有率来排序 T 根据进程运行时间的长短来排序 U 可以根据后面输入的用户名来筛选进程 K 可以根据后面输入的PID来杀死进程 q 退出 h 获得帮助 5.终止进程：kill kill命令指定进程号的进程，需要配合ps使用 使用格式： kill [-signal] pid 信号值从0到15，其中9为绝对终止，可以处理一般信号无法终止的进程。 kill 9133 : 杀死进程号为9133所对应的应用程序 6.关机重启：reboot/shutdown/init 命令 含义 reboot 重新启动操作系统 shutdown -r now 重新启动操作系统，shutdown会给别的用户提示 shutdown -h now 立刻关机，其中now相当于时间为0的状态 shutdown -h 20:25 系统在今天的20:25关机 shutdown -h +10 系统再过十分钟后自动关机 init 0 关机 init 6 重启 7.检测磁盘空间：df df命令用于检测文件系统的磁盘空间占用和空余情况，可以显示所有文件系统对节点和磁盘块的使用情况。 选项 含义 -a 显示所有文件系统的磁盘使用情况 -m 以1024字节单位显示 -t 显示各指定文件系统的磁盘空间使用情况 -T 显示文件系统 8.检测目录所占磁盘空间：du du命令用于统计目录或文件所占磁盘空间的大小，该命令的执行结果与df类似，du更侧重于磁盘的使用状况。 du命令的使用格式如下：du [选项] 目录或文件名 选项 含义 -a 递归显示指定目录中各文件和子目录中文件占用的数据库 -s 显示指定文件或目录占用的数据块 -b 以字节为单位显示磁盘占用情况 -l 计算所有文件大小，对硬链接文件计算多次 9.查看或配置网卡信息：ifconfig10.测试远程主机连通性：ping ping 192.168.0.1 -c 4","tags":[{"name":"linux","slug":"linux","permalink":"http://blog.xmqbeast.com/tags/linux/"}]},{"title":"MarkDown一些常用语法","date":"2017-04-26T02:51:45.000Z","path":"2017/04/26/MarkDown一些常用语法/","text":"1.引入代码 12345public class Main &#123; public static void main(String[] args) &#123; System.out.println(\"Hello World\"); &#125;&#125; 12var s = \"Javascript syntax hightlighting\";alert(s); 2.链接(Links)Markdown中有两种方式，实现链接，一种是内联方式，另一种是引用方式 内联方式：This is an baidu link 引用方式：I get 10 times more traffic from Google than from Yahoo or MSN. 3.分割线 “一个空行”加上“连续3个以上的减号符号(即—)”的组合，使得得到一个分割线。 快捷键：Ctrl+R 4.表格 使用“|”符号隔开不同列，第一行作为列名行，第二行必须为一个格式控制行，表明整个内容以表格形式展示。格式控制行最简单的样式如“|-|-|-|”所示，这表示以3列的形式展示表格。在“-”的左边加“:”（即“:-”），表示单元格的内容左对齐;在“-”的右边加“:”（即“-:”），表示单元格的内容右对齐;在“-”的两边加“:”（即“:-:”），表示单元格的内容居中对齐。比如现在有如下内容： 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234","tags":[]},{"title":"linux 常用命令","date":"2017-04-25T12:12:52.000Z","path":"2017/04/25/linux-常用命令/","text":"1.linux 命令格式 1command [-options] [parameter1] ··· 说明：·command:命令名，相应功能的英文单词或单词的缩写[-option]:选项，可用来对命令进行控制，也可以省略，[]代表可选 parameter1…:传递给命令的参数：可以是零个或多个 例： 1ls -a /home/xiaoti 2.查看帮助文档 –help一般是linux命令自带的帮助信息如：ls –help man(有问题找男人，manual)man是linux提供的一个手册,包含了绝大部分的命令，函数使用说明该手册分成很多章节(section)，使用man时可以指定不同的章节来浏览例：man ls; man 2 printf man中各个section意义如下：1.Standard commands(标准命令)2.System calls(系统调用,如open,write)3.Library functions(库函数，如printf,fopen)4.Special devices(设备文件的说明,/dev下各种设备)5.File formats(文件格式，如passwd)6.Games and toys(游戏和娱乐)7.Miscellaneous(杂项、惯例和协定等，例如Linux档案系统、网络协定、ASCII码、environ全局变量)8.Administrative Commands(管理员命令，如ifconfig) man是按照手册的章节号的顺序进行搜索的。 man设置了如下的功能键 功能键 功能 空格键 显示手册页的下一屏 Enter键 一次滚动手册页的一行 b 回滚一屏 f 前滚一屏 q 退出man命令 h 列出所有功能键 /word 搜索word字符串","tags":[{"name":"linux","slug":"linux","permalink":"http://blog.xmqbeast.com/tags/linux/"}]},{"title":"Introduction of Elasticsearch","date":"2017-04-14T03:51:47.000Z","path":"2017/04/14/Introduction-of-Elasticsearch/","text":"Elasticsearch is a highly scalable open-source full-text search and analytics engine. It allows you to store, search, and analyze big volumes of data quickly and in near real time. It is generally used as the underlying engine/technology that powers applications that have complex search features and requirements. Here are a few sample use-cases that Elasticsearch could be used for: You run an online web store where you allow your customers to search for products that you sell. In this case, you can use Elasticsearch to store your entire product catalog and inventory and provide search and autocomplete suggestions for them. You want to collect log or transaction data and you want to analyze and mine this data to look for trends, statistics, summarizations, or anomalies. In this case, you can use Logstash (part of the Elasticsearch/Logstash/Kibana stack) to collect, aggregate, and parse your data, and then have Logstash feed this data into Elasticsearch. Once the data is in Elasticsearch, you can run searches and aggregations to mine any information that is of interest to you. You run a price alerting platform which allows price-savvy customers to specify a rule like “I am interested in buying a specific electronic gadget and I want to be notified if the price of gadget falls below $X from any vendor within the next month”. In this case you can scrape vendor prices, push them into Elasticsearch and use its reverse-search (Percolator) capability to match price movements against customer queries and eventually push the alerts out to the customer once matches are found.You have analytics/business-intelligence needs and want to quickly investigate, analyze, visualize, and ask ad-hoc questions on a lot of data (think millions or billions of records). In this case, you can use Elasticsearch to store your data and then use Kibana (part of the Elasticsearch/Logstash/Kibana stack) to build custom dashboards that can visualize aspects of your data that are important to you. Additionally, you can use the Elasticsearch aggregations functionality to perform complex business intelligence queries against your data. For the rest of this tutorial, I will guide you through the process of getting Elasticsearch up and running, taking a peek inside it, and performing basic operations like indexing, searching, and modifying your data. At the end of this tutorial, you should have a good idea of what Elasticsearch is, how it works, and hopefully be inspired to see how you can use it to either build sophisticated search applications or to mine intelligence from your data.","tags":[]},{"title":"What is Practice?","date":"2017-04-13T09:28:39.000Z","path":"2017/04/13/What-is-Practice/","text":"When I’m saying “Practice”, what does it mean? I would say: Practice is a habit. Practice is a routine. Practice does not need to remember. Practice comes by practicing. Practice needs dedication and commitment. There are thousands of examples which you think about practice. I can list few for your understanding. Shooting, Driving, Writing Any of the above listed skills comes from practice. When initially you start driving, you need to remember each step and you think twice before taking any action, but once you “have good practice” of driving, then you do not need to remember any step. It becomes your habit and routine, for example, your feet goes automatically at brake if you see a red light but definitely it comes from practising a lot and needs a lot of dedication and commitment. One of the most important attributes of practice is that it forces you not to divert from what you used to do. There could be a driver but would you assume him an efficient driver if he is driving at a speed of 20 miles per hours and meeting with accidents so frequently and bringing lots of scratches in the car on a daily basis? Software development is also not different than other skills like shooting, writing or driving. To become a successful software developer you need lot of practice, dedication and commitment. Through this small article, I’m going to tell you few major best software developer’s practices, which you may find useful.","tags":[]},{"title":"关于spring事务","date":"2017-04-13T08:58:34.000Z","path":"2017/04/13/关于spring事务/","text":"在企业级应用程序开发中，事务管理必不可少的技术，用来确保数据的完整性和一致性。事务有四个特性：ACID 原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。 事务的传播属性 REQUIRED (默认) 业务方法需要在事务中运行,如果方法运行的时候已经开启事务,就加入事务,否则创建新的事务 NOT_SUPPORTED 声明方法不需要开启事务.如果已经开启事务后调用该方法.则先挂起该事务,方法执行完毕后,事务恢复 REQUIRES_NEW 不管是否存在事务,都另行开启新的事务.如果先前已经开启事务,挂起原先事务.创建新的事务. 新的事务执行结束后,恢复原先事务 MANDATORY 只能在已经存在的事务中执行,不能自行创建事务,如果在没有开启事务的环境下调用,容器抛出例外 SUPPORTS 墙头草,有事务就在事务中执行.没事务就在没事务的环境下执行 NEVER 绝对不能在事务中执行.如果执行.抛出例外 NESTED 如果有事务存在,开启一个新事务嵌套在上层事务中.开启的新事务具有自己独立的回滚点.新事务的回滚不会对外部事务造成影响, 但是外部事务的提交会直接提交嵌套事务 如果没有事务存在,则按照REQUIRED属性执行,该属性只对DataSourceTransationManager事务管理器有效","tags":[]},{"title":"git一些常用命令","date":"2017-04-12T13:10:44.000Z","path":"2017/04/12/git一些常用命令/","text":"1.怎么用git删除远程分支？git v1.7.0之后，可以使用一下语法删除远程分支.1$ git push origin --delete &lt;branchName&gt; 删除tag可以使用命令：1$ git push origin --delete tag &lt;tagName&gt; 还可以使用推送一个空分支到远程分支的方式来删除远程分支：1git push origin :&lt;branchName&gt; 2.本地项目文件夹推送到git远程仓库一般步骤 1git init git add (文件名)注意:使用git add命令添加需要上传的文件到缓存中,而不是上传过去1git add . 1git commit -m \"message\" 1234567git remote add origin https://github.com/xtzeng/xmq-spring-transation-parent.git``` 我们第一次push的时候,加上-u参数,Git就会把本地的master分支和远程的master分支进行关联起来,我们以后的push操作就不再需要加上-u参数了```bashgit push -u origin master","tags":[]},{"title":"开始使用hexo写自己的blog","date":"2017-04-12T10:37:58.000Z","path":"2017/04/12/开始使用hexo写自己的blog/","text":"about hexo about markdown 一直想搭建一个属于自己的博客，以前都是在csdn或博客园上面写，最近一直在搭建github的hexo博客，折腾了几天时间，终于可以小试牛刀写点属于自己的东西，日后某一天回来看的时候，也许觉得那时候的自己是个煞笔，但能有所成长，也就足够了。以下是关于这几天在github搭建hexo的一些心得。 关于在不同的电脑（系统）上使用hexo将自己的blog文件夹使用git来管理，需要注意一下几点：1.如果主题是通过git管理的，需要将主题文件夹下的.git文件夹删除，才能同步blog文件夹。（如果.git文件夹是隐藏的，需要显示隐藏文件才能删除，linux下用命令rm -rf命令删除）2.按照blog目录下自带的.gitignore文件，node_modules文件夹是不会同步的，所以同步之后需要自己再次npm install,但是要注意一点，不要再进行hexo init了，否则 _config.yml就全都白弄了 必须拷贝的文件：_config.yml,theme文件夹里面的主题，以及source里面自己写的blog文件,这些肯定是要拷贝的.除此之外还有三个文件需要保留，就是scaffolds文件夹(文章的模板)、packeage.json(说明使用哪些包) 还有.gitignore(限定在提交的时候哪些文件可以忽略)。其实这三个文件不用我们修改的，所以即使丢失了也没有关系，我们可以另外新建一个临时文件夹，然后在里面执行hexo init,就可以生成这三个文件，我们只需要将它们拷贝过来使用即可。总结：_config.yml、theme/、source/、scaffolds/、package.json、.gitignore是需要备份的。 然后我们再考虑哪些文件是不需要拷贝、或者说可以删除的首先是.git文件夹，无论是在站点根目录下，还是主题目录下的.git文件，都可以删掉。然后是文件夹node_modules(在用npm install 会重新生成)、public文件夹(这个在使用命令hexo g后会重新生成)，deploy_git文件夹(在使用hexo d后也会重新生成),还有db.json文件.其实这些文件也就是.gitignore文件里面记载的内容.总结：.git/、node_modules/、public/、deploy_git/、db.json文件可以删除","tags":[]}]